#!/usr/bin/python3
# userdata: system for user authentication and data storage.
# This is the server program, which manages the data.

# XXX: allow using public key authentication instead of password.
# Possibly not a good idea, because it suggests better protection than what is provided.
# (Iow: when doing that, also move to using that key for encrypting all communication.)

'''
Interface: {{{

Summary:

This program provides access to data for users and games.
The data is organized as:
- administrative: user names, passwords
	user: name, game, containers, password, email	(if containers is NULL, this is the master login for the user; otherwise it is a tab-separated list of containers (in a string))
- per user and per container:
	- admin data for managed players
		username-containername-player: name, password, email
	- other data for managed players
		username-containername-playername-*: any format
	- other data for container, or for player owner in possibly remote game
		username-containername--*: any format

Terminology:
	- user: human owner of managed data.
	- player: human person to who the managed data applies, who may or may not also be the owner of that data.
	- browser: program through which users and players interact with their game server and the userdata server.
	- userdata server: this program, it manages the data for several users and several containers.
	- game server: a program that provides a game interface to players and connects to one or more userdata servers to store its data.
	- token: a cryptographically hard to guess string that allows access to a user's data. The user receives it after logging in and should pass it to the game server.

Game protocol, option 0: all data owned by game; no player logins:
	- game -> userdata: login_game()
	- game -> userdata: select() etc.

Game protocol, option 1: player data is not owned by the game:
	- game -> userdata: login_game()        At boot, the game server connects to its userdata to store game data.
	- game -> player: setup_userdata()       Game provides gcid, game settings, etc to player at connect.
	-		When a player connects to the game, a userdata server is selected based on the game settings (with/without default; allow-local, allow-external)
	- player -> userdata: login_user()      Player connects to userdata and logs in
	- player -> userdata: connect()         Player instructs userdata to connect to game, passing game url and token
	- userdata -> game: connect (or setup_connect())           Userdata connects to game, passing token
	- game -> player: setup_userdata()     Player waits for connection to complete; this call blocks until userdata connection is established.
	- game -> userdata: select etc.

Game protocol, option 2: player data is owned by the game:
	- game -> userdata: login_game()                Same as above
	- game -> userdata: create_dcid()      Allow players to log in on this game; this token is encoded in the url given to players.
	- game -> player: token()       Game provides token to player at connect; game settings are passed as argument.
	-		When a player connects to the game, a userdata server is selected based on the game settings (with/without default; allow-local, allow-external)
	- player -> userdata: login_player()    Player connects to local userdata and logs in, passing token
	- userdata -> game: setup_connect_player()           Userdata passes token to game
	- game -> userdata: select etc.

Data management protocol:
	- Option 1: User connects directly to userdata and logs in
	- Option 2: User logs in through a game that allows external userdata, then selects "manage data".
	Both options need login_user() to be used. login_player() does not allow access to the data.
	Data management browser interface still needs to be designed.
	Alternatively, when logging in through a program, regular database commands can be used.

Possible connections to userdata server (this program):

From game:	self.game = (game, ...); self.user = username or None; self.manage = False
	- login_game(player_id, game_info, name = None, password = None): set game info for login_token; use game data if credentials are supplied. Set self.game = game_info
	- logout(player_id): Remove player from list of accessible data.
	- [db_access](game, player_id, ...): All db access uses the player id as first argument. It should be set to None for the game data.

From user:	self.game = None; self.user = username; self.manage = True
	- login_user(name, password): manage user data; full access. Set self.user = name.
	- list_games(): return all games that have data (index in this list is the game for this connection)
	- list_players(game): return all valid players (stored under this user) for the game.
	- [db_access](game, player_id, ...): same interface as from game

From player:	self.game = None; self.user = username; self.player = playername or None; self.manage = False
	- login_user(name, password, game_info): return token. Connection is closed when game provides token. Token is invalidated if this connection is closed before it is used. This connection can be used for data management until the token is used. Set server.player[token] = self.
	- login_player(username, playername, password, game_info): return token; same as above, use player account inside user's data. Set server.player[token] = self.

Database format:

All tables have a prefix if set on the commandline using --prefix.
User tables have an additional (after the global prefix) prefix of 'username-containername-playername-'.
The [containername]-prefix is the [container1]-field in the user table (not the id provided by the game itself).
For game data and for login_user()-data, playername is "". In other words, the prefix is 'username-containername--'.
The userdata server never changes user tables except as asked by authorized users.
Internal data is (all tables have the global prefix):
	user: name, password, email
		list of recognized users
	[username]-games: name
		list of games for this user
	[username]-user: game, password, container_name, games
		list of valid game logins for this user. game is passed on login. container_name is used when communicating, such as in emails. containers is a tab-separated list of accessible databases.
	[username]-[containername]-player: name, password, email
		list of managed players for this game

}}}
'''

# Imports and config. {{{
import sys
import traceback
import secrets
import urllib
import websocketd
import db
import re
import fhs
fhs.option('port', 'Port to listen on for game server requests', default = '8879')
fhs.option('authport', 'Port to listen on for authentication requests; leave empty for same as game server requests', default = '')
fhs.option('prefix', 'Prefix to use for all database tables', default = '')
fhs.option('allow-new-users', 'Allow new users to register', argtype = bool)
fhs.option('url', 'override url for auth host (defaults to same as connect host)', default = '')
fhs.option('list', 'list available data at startup', argtype = bool)
config = fhs.init(contact = 'Bas Wijnen <wijnen@debian.org>', help = 'Server for handling user data', version = '0.1')

if len(sys.argv) != 1:
	print('non-option arguments are ignored', file = sys.stderr)
# }}}

# Pending login requests for managed players (key is dcid, value is dict {'game': object, 'channel': int, 'gcid': token})
pending_player_login = {}
# Pending items are moved to active at login; active items are allowed to open a settings connection. There records have an extra item: 'name': str, which is the managed name or None for external players. Gcid is also None for external players.
active_player = {}

# Translations {{{
translations = {}
def _(template, language, *args):
	'Mark translatable strings. Use as _("The name is $1", "Sir Lancelot", language = "nl")'
	if language in translations:
		dictionary = translations[language]
		if template in dictionary:
			template = dictionary[template]
		else:
			print('Warning: template "%s" not defined for language "%s".' % (template, language), file = sys.stderr)
	else:
		print('Warning: language "%s" not defined' % language, file = sys.stderr)
	def replace(match):
		n = int(match.group(1))
		if not 1 <= n <= len(args):
			print('Warning: template "%s" references invalid argument %d' % (template, n), file = sys.stderr)
			return b'[%d]' % n
		return args[n - 1]
	return re.sub(rb'\$(\d)', template, replace)

def N_(template):
	'Mark translatable string, that should not be translated where they are defined.'
	return template
# }}}

def make_dcid(container1, container2):	# {{{
	'Generate a cryptographically hard to guess token that is not present in the container dict'
	dcid = secrets.token_urlsafe()
	while dcid in container1 or dcid in container2:
		dcid = secrets.token_urlsafe()
	return dcid
# }}}

class Connection_Base:
	def __init__(self, remote):
		self.remote = remote
	def assertion(self, check): # {{{
		'''Assert without throwing an exception.
		Return True if assertion was triggered (so the function should abort).'''
		if check:
			return False
		print('Assertion failed')
		traceback.print_stack()
		self.remote._websocket_close()
		return True
	# }}}

class Connection(Connection_Base): # {{{
	'''This connection is opened by the game directly (for its own data),
	or by the player through a login url. Games may request a link for
	letting managed users log in. Those will also log in through an
	instance of this class.

	Finally, when a non-managed user requests to be connected to a remote
	game, a new object of this class is created to handle that new
	connection.
	'''

	def __init__(self, remote = None): # {{{
		'Constructor. Remote is None for objects that will connect to a remote game.'
		super().__init__(remote)
		self.game_url = None

		# Users that are logged in on this connection.
		# Keys are channels given as arguments to login_*. Those are managed by the game and opaque to this program. Their type is int.
		# Values are dicts containing:
		#	- 'user': db username
		#	- 'pending-dcid': tokens for logging players into this game, or None; stored in pending_player_login.
		#	- 'active-dcid': tokens for logged in players, or None; stored in active_player.
		# Example:
		# self.channel = {
		#   0: {'user': 'shevek', 'pending-dcid': None, 'active-dcid': None},		# Data management.
		#   10: {'user': 'shevek', 'pending-dcid': {}, 'active-dcid': {}}	# Game login, with a dcid list for player logins and active players.
		# }
		self.channel = {}

		if remote is not None:
			# Register cleanup function.
			remote._websocket_closed = self._closed

			# Record dcid if present.
			# The presence of a dcid means this object will attempt to log in as a managed player.
			if 'dcid' in remote.data['query']:
				# This is a managed player login.
				self.settings = False
				dcids = remote.data['query']['dcid']
				if len(dcids) != 1:
					print('invalid dcids in query string', file = sys.stderr)
					remote._websocket_close()
					return
				self.dcid = dcids[0]
				if self.dcid in active_player:
					print('dcid in query string for already logged in user', file = sys.stderr)
					remote._websocket_close()
					return
				elif self.dcid not in pending_player_login:
					# This connection uses an invalid dcid.
					print('invalid dcid in query string', file = sys.stderr)
					remote._websocket_close()
			else:
				# This is a game, or an external player logging in.
				self.settings = False
				self.dcid = None
		else:
			# This is a connect() request; the connection will be initiated from here.
			self.settings = False
			self.dcid = None
	# }}}

	def _closed(self):	# {{{
		'''Clean up registered tokens.'''
		for channel in self.channel:
			for c in (('pending-dcid', pending_player_login), ('active-dcid', active_player)):
				collection = self.channel[channel][c[0]]
				if collection is not None:
					for gcid, dcid in collection.items():
						#print('removing %s from %s' % (dcid, c[0]), file = sys.stderr)
						del c[1][dcid]
					self.channel[channel][c[0]] = {}
		# Remove this game from list of connected games.
		if self.game_url in server.games:
			del server.games[self.game_url]
	# }}}

	def get_settings(self): # {{{
		return {'allow-new-users': config['allow-new-users']}
	# }}}

# Registering new users. {{{
	def register_user(self, name, fullname, email, password):
		if self.assertion(config['allow-new-users']):
			return
		return db.setup_add_user(name, fullname, email, password)
	def register_managed_player(self, name, fullname, email, password):
		if self.dcid not in pending_player_login:
			print('invalid dcid', file = sys.stderr)
			return 'invalid dcid'
		record = pending_player_login[self.dcid]
		connection = record['game']
		channel = record['channel']
		game = connection.channel[channel]['game']
		if self.assertion(game['allow-new-players']):
			return
		return db.setup_add_managed_player(game['id'], name, fullname, email, password)
# }}}

# Logins. {{{
	def login_game(self, channel, user_name, game_name, password, allow_new_players): # {{{
		'Allow connection to be used for game data access.'
		if self.assertion(channel not in self.channel):
			return
		# Verify credentials
		game = db.authenticate_game(user_name, game_name, password)
		game['allow-new-players'] = allow_new_players
		if game is None:
			return False
		# Record permissions
		self.channel[channel] = {'user': game['user'], 'game': game, 'player': None, 'managed': None, 'pending-dcid': {}, 'active-dcid': {}}
		return True
	# }}}

	def login_user(self, channel, name, password): # {{{
		'Allow connection for user management access, including game login authorization.'
		if self.assertion(channel not in self.channel):
			return
		# Verify credentials
		user = db.authenticate_user(name, password)
		if user is None:
			return False
		# Record permissions
		self.channel[channel] = {'user': user['id'], 'game': None, 'player': None, 'managed': None, 'pending-dcid': None, 'active-dcid': None}
		return True
	# }}}

	def login_player(self, player_name, password): # {{{
		'''Log in managed player. Player data is managed by game, not by its own user.
		The dcid must have been passed as part of url.
		In response, userdata (this program) will inform game.
		No state change happens in userdata.
		'''
		if self.dcid not in pending_player_login:
			print('invalid dcid', file = sys.stderr)
			return False
		record = pending_player_login[self.dcid]
		connection = record['game']
		channel = record['channel']
		gcid = record['gcid']
		game = connection.channel[channel]
		player = db.authenticate_player(game['game']['id'], player_name, password)
		if player is None:
			print('invalid player credentials', file = sys.stderr)
			return False
		self.drop_pending_dcid(channel, self.dcid)
		if self.assertion(self.dcid not in active_player):
			return
		record['name'] = player['name']
		active_player[self.dcid] = record
		record['game'].channel[record['channel']]['active-dcid'][record['gcid']] = self.dcid
		connection.remote.setup_connect_player.event(channel, gcid, player['name'], player['fullname'], player['language'])
		return True
	# }}}

	def create_dcid(self, channel, gcid): # {{{
		'''Allow a player to log in on this game.
		The returned dcid must be passed by the user in the query string of the request.
		This allows the browser to send it for its connection that calls login_player().
		'''
		if self.assertion(self.channel[channel]['pending-dcid'] is not None):
			return
		if self.assertion(gcid is not None):
			return
		if gcid in self.channel[channel]['pending-dcid']:
			return self.channel[channel]['pending-dcid'][gcid]
		if self.assertion(gcid not in self.channel[channel]['active-dcid']):
			return
		dcid = make_dcid(pending_player_login, active_player)
		self.channel[channel]['pending-dcid'][gcid] = dcid
		#print('adding %s to pending' % dcid)
		pending_player_login[dcid] = {'game': self, 'channel': channel, 'gcid': gcid}
		return dcid
	# }}}

	def drop_pending_dcid(self, channel, dcid): # {{{
		'''Revoke a previously generated dcid.
		After this, players using the dcid will no longer be able to log in.
		'''
		#print('drop pending; channel', channel, 'dcid', dcid, 'pending player', pending_player_login)
		# FIXME: channel is not checked for validity
		if self.assertion(dcid in pending_player_login):
			return
		record = pending_player_login.pop(dcid)
		#print('drop pending; channel', record, 'game', record['game'].channel[record['channel']])
		if self.assertion(record['game'].channel[record['channel']]['pending-dcid'][record['gcid']] == dcid):
			return
		del record['game'].channel[record['channel']]['pending-dcid'][record['gcid']]
	# }}}

	def drop_active_dcid(self, channel, dcid): # {{{
		'''Revoke a previously generated dcid.
		After this, players using the dcid will no longer be able to change their settings through this token.
		'''
		#print('drop active; channel', channel, 'dcid', dcid, 'active player', active_player)
		# FIXME: channel is not checked for validity
		if self.assertion(dcid in active_player):
			return
		record = active_player.pop(dcid)
		#print('drop active; channel', record, 'game', record['game'].channel[record['channel']])
		if self.assertion(record['game'].channel[record['channel']]['active-dcid'][record['gcid']] == dcid):
			return
		del record['game'].channel[record['channel']]['active-dcid'][record['gcid']]
	# }}}

	def connect(self, channel, game_url, attrs, player): # {{{
		'''Connect to game server.
		This is called when a remote (to the game) player has logged in to this userdata.
		This function can only be called by a logged in user.'''
		wake = (yield)
		if self.assertion(self.is_user(channel)):
			return
		storage = db.setup_get_player(self.channel[channel]['user'], game_url, player)
		if self.assertion(storage is not None):
			return
		if game_url in server.games:
			# Game is already connected, use existing connection.
			game = server.games[game_url]['game']
			connection = server.games[game_url]['connection']
			channel = server.games[game_url]['channel'] + 1
			server.games[game_url]['channel'] = channel
			connection.channel[channel] = {'user': self.channel[channel]['user'], 'game': None, 'player': storage['id'], 'managed': None, 'pending-dcid': None, 'active-dcid': None}
			game.setup_connect.bg(wake, channel, storage['fullname'], storage['language'], **attrs)
			yield
		else:
			# Game is not connected, create new connection.
			connection = Connection()	# Create new object for this connection.
			connection.game_url = game_url
			channel = 0
			connection.channel[channel] = {'user': self.channel[channel]['user'], 'game': None, 'player': storage['id'], 'managed': None, 'pending-dcid': None, 'active-dcid': None}
			def accept(remote):
				if self.assertion(connection.remote is None):
					return
				connection.remote = remote
				return connection
			attrs['channel'] = channel
			attrs['name'] = storage['fullname']
			game = websocketd.RPC(game_url + '?' + '&'.join('%s=%s' % (key, urllib.parse.quote_plus(str(value))) for key, value in attrs.items()), accept)	# XXX This will block and allows a denial of service attack.
			game._websocket_closed = connection._closed
			server.games[game_url] = {'game': game, 'channel': channel, 'connection': connection}
		dcid = make_dcid(pending_player_login, active_player)
		#print('adding %s to active' % dcid, file = sys.stderr)
		active_player[dcid] = {'game': connection, 'channel': channel, 'gcid': None, 'name': None}
		return dcid
	# }}}

	def access_game(self, channel, new_channel, user_name, game_name): # {{{
		pass # TODO: Implement access_game()
	# }}}

	def access_player(self, channel, new_channel, url, player_name): # {{{
		pass # TODO: Implement access_player()
	# }}}

	def access_managed_player(self, channel, new_channel, player_name): # {{{
		if self.assertion(new_channel not in self.channel):
			return
		player = db.find_managed(self.channel[channel]['game']['id'], player_name)
		if self.assertion(player is not None):
			return
		self.channel[new_channel] = {'user': self.channel[channel]['user'], 'game': None, 'player': None, 'managed': player['id'], 'pending-dcid': None, 'active-dcid': None}
	# }}}
# }}}


# Database management. {{{
# Games (called by logged in users; manage games that can be used with login_game()). {{{
	def list_games(self, channel): # {{{
		'Can only be called for logged in users. Lists all games (for use by login_game()) for that user.'
		if self.assertion(self.is_user(channel)):
			return
		return db.setup_list_games(self.channel[channel]['user'])
	# }}}

	def add_game(self, channel, game_name, game_fullname, password): # {{{
		'Can only be called for logged in users. Creates a new game in the database.'
		if self.assertion(self.is_user(channel)):
			return
		return db.setup_add_game(self.channel[channel]['user'], game_name, game_fullname, password)
	# }}}

	def update_game(self, channel, old_game_name, game_name, game_fullname, password): # {{{
		'Can only be called for logged in users. Updates settings for an existing game in the database.'
		if self.assertion(self.is_user(channel)):
			return
		game_id = db.find_game(self.channel[channel]['user'], old_game_name)
		if self.assertion(game_id is not None):
			return
		return db.setup_update_game(game_id, self.channel[channel]['user'], game_name, game_fullname, password)
	# }}}

	def remove_game(self, channel, game_name): # {{{
		'Can only be called for logged in users. Removes a game from the database.'
		if self.assertion(self.is_user(channel)):
			return
		game_id = db.find_game(self.channel[channel]['user'], game_name)
		if self.assertion(game_id is not None):
			return
		return db.setup_remove_game(game_id)
	# }}}
# }}}

# Remote players. (called by logged in users; manage players that can be used with external games.) {{{
	def list_players(self, channel, url = None): # {{{
		'Can only be called for logged in users. Lists all remote players (for use with connect()) of that user.'
		if self.assertion(self.is_user(channel)):
			return
		return db.setup_list_players(self.channel[channel]['user'], url)
	# }}}

	def add_player(self, channel, url, player_name, player_fullname, is_default): # {{{
		'Can only be called for logged in users. Adds a player for a game to the database.'
		if self.assertion(self.is_user(channel)):
			return
		return db.setup_add_player(self.channel[channel]['user'], url, player_name, player_fullname, is_default)
	# }}}

	def update_player(self, old_player_name, channel, url, player_name, player_fullname, language, is_default): # {{{
		'Can only be called for logged in users. Updates settings of an existing player in the database.'
		if self.assertion(self.is_user(channel)):
			return
		player = db.find_player(self.channel[channel]['user'], url, old_player_name)
		if self.assertion(player is not None):
			return
		return db.setup_update_player(player['id'], self.channel[channel]['user'], url, player_name, player_fullname, language, is_default)
	# }}}

	def remove_player(self, channel, url, player_name): # {{{
		'Can only be called for logged in users. Removes a player from the database.'
		if self.assertion(self.is_user(channel)):
			return
		player = db.find_player(self.channel[channel]['user'], url, player_name)
		if self.assertion(player is not None):
			return
		return db.setup_remove_player(player['id'])
	# }}}
# }}}

# Local (managed) players. Called by logged in users or games; manage players that can be used with logged in games. {{{
	def list_managed_players(self, channel, game_name = None): # {{{
		'''Can only be called for logged in users and logged in games. Lists all managed players (for login_player()) for given game of that user.
		For logged in games, game_name must be set to its own game (or None)
		'''
		if self.assertion(self.is_user(channel) or self.is_game(channel)):
			return
		if game_name is None:
			if self.assertion(self.is_game(channel)):
				return
			game_id = self.channel[channel]['game']['id']
		else:
			game_id = db.find_game(self.channel[channel]['user'], game_name)
			if self.is_game(channel):
				if self.assertion(self.channel[channel]['game']['id'] == game_id):
					return
		return [{key: value for key, value in x.items() if key in ('name', 'fullname', 'email')} for x in db.setup_list_managed_players(game_id)]
	# }}}

	def add_managed_player(self, channel, game_name, name, fullname, email, password): # {{{
		'Can only be called for logged in users. Adds a managed player (for login_player()) for a game to the database.'
		if self.assertion(self.is_user(channel) or self.is_game(channel)):
			return
		game_id = find_game(self.channel[channel]['user'], game_name)
		if self.assertion(game_id is not None):
			return
		if self.is_game(channel):
			if self.assertion(self.channel[channel]['game']['id'] == game_id):
				return
		return db.setup_add_managed_player(game_id, name, fullname, email, password)
	# }}}

	def update_managed_player(self, channel, old_player_name, game_name, name, fullname, email, password): # {{{
		'Can only be called for logged in users. Updates settings of an existing player in the database.'
		if self.assertion(self.is_user(channel) or self.is_game(channel)):
			return
		game_id = db.find_game(self.channel[channel]['user'], game_name)
		if self.assertion(game_id is not None):
			return
		if self.is_game(channel):
			if self.assertion(self.channel[channel]['game']['id'] == game_id):
				return
		managed = db.find_managed(game_id, old_player_name)
		if self.assertion(managed is not None):
			return
		return db.setup_update_managed_player(managed['id'], game_id, name, fullname, email, password)
	# }}}

	def remove_managed_player(self, channel, game_name, name): # {{{
		'Can only be called for logged in users. Removes a player from the database.'
		if self.assertion(self.is_user(channel) or self.is_game(channel)):
			return
		game_id = find_game(self.channel[channel]['user'], game_name)
		if self.assertion(game_id is not None):
			return
		if self.is_game(channel):
			if self.assertion(self.channel[channel]['game']['id'] == game_id):
				return
		player = find_managed(game_id, name)
		return db.setup_remove_managed_player(player['id'])
	# }}}
# }}}
# }}}

	def disconnected(self, channel): # {{{
		'User disconnected from game; drop userdata connection, optionally close connection to game'
		if self.channel[channel]['pending-dcid'] is not None:
			# This is a game connection; clean up managed players.
			for gcid, dcid in self.channel[channel]['pending-dcid'].items():
				#print('removing %s from pending (gcid: %s)' % (dcid, gcid), file = sys.stderr)
				del pending_player_login[dcid]
			self.channel[channel]['pending-dcid'] = None
		if self.channel[channel]['active-dcid'] is not None:
			# This is a game connection; clean up managed players.
			for gcid, dcid in self.channel[channel]['active-dcid'].items():
				del active_player[dcid]
			self.channel[channel]['active-dcid'] = None
		del self.channel[channel]
		if len(self.channel) == 0:
			self.remote._websocket_close()
			del server.games[self.game_url]
	# }}}

	# Check roles. {{{
	def is_user(self, channel):
		'Return True if this connection is a user (not a player).'
		if self.assertion(channel in self.channel):
			return
		ch = self.channel[channel]
		return ch['game']['id'] is None and ch['player'] is None and ch['managed'] is None

	def is_game(self, channel):
		'Return True if this connection is a game.'
		if self.assertion(channel in self.channel):
			return
		return self.channel[channel]['game'] is not None

	def is_player(self, channel):
		'Return True if this connection is an external (to the game) player.'
		if self.assertion(channel in self.channel):
			return
		return self.channel[channel]['player'] is not None

	def is_managed(self, channel):
		'Return True if this connection is a managed player.'
		if self.assertion(channel in self.channel):
			return
		return self.channel[channel]['managed'] is not None
	# }}}

	# Database access. {{{
	def _mktable(self, channel, table): # {{{
		if self.is_game(channel):
			# This is a game connection.
			return db.global_prefix + 'g%x_' % self.channel[channel]['game']['id'] + table
		if self.is_player(channel):
			# This is a (remote) player connection.
			return db.global_prefix + 'p%x_' % self.channel[channel]['player'] + table
		if self.is_managed(channel):
			# This is a managed player connection.
			return db.global_prefix + 'm%x_' % self.channel[channel]['managed'] + table
		raise PermissionError('this connection has no database access.')
	# }}}
	def show_tables(self, channel): # {{{
		'Return all tables for given game, accessible to logged in user.'
		if self.assertion(channel in self.channel):
			return
		prefix = self._mktable(channel, '')
		return [x[len(prefix):] for x in db.read1('SHOW TABLES') if x.startswith(prefix)]
	# }}}

	def describe(self, channel, table): # {{{
		'give table description in mysql format; interface may not be stable. Use show_columns instead if you can.'
		# This returns the output from mysql, which may or may not be a stable interface.
		if self.assertion(channel in self.channel):
			return
		return db.read('DESCRIBE %s' % self._mktable(channel, table))
	# }}}

	def show_columns(self, channel, table): # {{{
		'return column names of given table'
		if self.assertion(channel in self.channel):
			return
		# Use read1 to only get the first column, which is the column names of the table.
		return db.read1('DESCRIBE %s' % self._mktable(channel, table))
	# }}}

	def create_table(self, channel, table, columns): # {{{
		'Create new table for this player.'
		if self.assertion(channel in self.channel):
			return
		if isinstance(columns, dict):
			columns = [(k, v) for k, v in columns.items()]
		for c in columns:
			db.assert_is_id(c[0])
		db.write('CREATE TABLE %s (%s)' % (self._mktable(channel, table), ', '.join('%s %s' % tuple(c) for c in columns)))
	# }}}

	def drop_table(self, channel, table): # {{{
		'Drop a table for this player.'
		if self.assertion(channel in self.channel):
			return
		db.write('DROP TABLE %s' % (self._mktable(channel, table)))
	# }}}

	def insert(self, channel, table, data): # {{{
		'''Insert a new record in the given table.
		Return last_insert_id().'''
		if self.assertion(channel in self.channel):
			return
		if isinstance(data, dict):
			data = [(k, v) for k, v in data.items()]
		for d in data:
			db.assert_is_id(d[0])
		db.write('INSERT INTO %s (%s) VALUES (%s)' % (self._mktable(channel, table), ', '.join(d[0] for d in data), ', '.join('%s' for d in data)), *tuple(d[1] for d in data))
		return db.read1('SELECT LAST_INSERT_ID()')[0]
	# }}}

	def delete(self, channel, table, condition): # {{{
		'Delete zero or more records from the given table.'
		if self.assertion(channel in self.channel):
			return
		c = self._parse_condition(condition)
		db.write('DELETE FROM %s%s' % (self._mktable(channel, table), c[0]), *c[1])
	# }}}

	def update(self, channel, table, data, condition): # {{{
		'Update records in given table.'
		if self.assertion(channel in self.channel):
			return
		c = self._parse_condition(condition)
		if isinstance(data, dict):
			data = [(k, v) for k, v in data.items()]
		columns = tuple(d[0] for d in data)
		values = tuple(d[1] for d in data)
		for col in columns:
			db.assert_is_id(col)
		db.write('UPDATE %s SET %s%s' % (self._mktable(channel, table), ', '.join('%s = %%s' % col for col in columns), c[0]), *(values + c[1]))
	# }}}

	def select(self, channel, table, columns, condition = ()): # {{{
		'Retrieve data from given table.'
		if self.assertion(channel in self.channel):
			return
		if isinstance(columns, str):
			columns = (columns,)
		for c in columns:
			db.assert_is_id(c)
		c = self._parse_condition(condition)
		return db.read('SELECT %s FROM %s%s' % (', '.join(columns), self._mktable(channel, table), c[0]), *c[1])
	# }}}

	def managed_select(self, channel, player, table, columns, condition = ()): # {{{
		'''Retrieve data from given table of managed player.
		This function must only be called from a game connection.
		It selects data from the managed player for the connection's game.
		'''
		if self.assertion(self.is_game(channel)):
			return
		game_id = self.channel[channel]['game']['id']
		if self.assertion(game_id is not None):
			return

		if isinstance(columns, str):
			columns = (columns,)
		for c in columns:
			db.assert_is_id(c)
		c = self._parse_condition(condition)
		managed = db.find_managed(game_id, player)
		t = db.global_prefix + 'm%x_' % managed['id'] + table
		return db.read('SELECT %s FROM %s%s' % (', '.join(columns), t, c[0]), *c[1])
	# }}}

	def _parse_condition(self, condition, simple = False): # {{{
		'''Parse a condition argument.
		Argument is an RPN expression tree.
		Nodes are ('and' | 'or' | 'not', branch1, branch2) (branch2 is omitted for not)
		Leaves are ('=' | '>' | '<' | '>=' | '<=' | '<>' | 'like', column, value)
		Return a 2-tuple, with the string in the query as the first item and the arguments as the second.
		'''
		# XXX: support more complex conditions.
		if len(condition) == 0:
			return ('', ())
		if condition[0].upper() in ('AND', 'OR'):
			c1 = self._parse_condition(condition[1], True)
			c2 = self._parse_condition(condition[2], True)
			return ' WHERE ' + c1[0] + ' ' + condition[0].upper() + ' ' + c2[0], c1[1] + c2[1]
		if condition[0].upper() not in ('=', '<', '>', '<=', '>=', '<>', 'LIKE'):
			raise NotImplementedError('Only simple conditions are supported at the moment')
		db.assert_is_id(condition[1])
		if condition[0] in ('=', '<>') and condition[2] is None:
			neg = '' if condition[0] == '=' else ' NOT'
			if simple:
				return (condition[1] + ' IS' + neg + ' NULL', ())
			else:
				return (' WHERE ' + condition[1] + ' IS' + neg + ' NULL', ())
		if simple:
			return (condition[1] + ' ' + condition[0].upper() + ' %s', (condition[2],))
		else:
			return (' WHERE ' + condition[1] + ' ' + condition[0].upper() + ' %s', (condition[2],))
	# }}}
	# }}}

	def _show_columns(self, channel, t): # {{{
		cmd = db.read('SHOW CREATE TABLE {}'.format(self._mktable(channel, t)))[0][1]
		p = re.match('CREATE TABLE `.*?` \((.*)\) ENGINE=.*$', cmd, re.S)
		if self.assertion(p is not None):
			return
		columns = [x.strip() for x in p.group(1).split(',')]
		ret = {}
		unique = set()
		pkey = None
		for c in columns:
			pk = re.match('^PRIMARY KEY \(`(.*)`\)$', c)
			if pk is not None:
				pkey = pk.group(1)
				continue
			u = re.match('^UNIQUE KEY `(.*)` \(`(.*)`\)$', c)
			if u is not None:
				if self.assertion(u.group(1) == u.group(2)):
					return
				unique.add(u.group(1))
				continue
		for c in columns:
			if not c.startswith('`'):
				continue
			col = re.match('^`(.*?)` (.*)$', c)
			ret[col.group(1)] = col.group(2)
			if col.group(1) in unique:
				ret[col.group(1)] += ' UNIQUE'
			if col.group(1) == pkey:
				ret[col.group(1)] += ' PRIMARY KEY'
		return ret
	# }}}
	def setup_db(self, channel, data, remove = True, add = True, replace = False): # {{{
		'Create tables of columns'
		if self.assertion(channel in self.channel):
			return
		tables = self.show_tables(channel)
		if remove or replace:
			for t in tables:
				if replace or (remove and t not in data):
					self.drop_table(channel, t)
		if add or replace:
			for t in data:
				datacolumns = {x[0]: x[1] for x in data[t]}
				if replace or (add and t not in tables):
					self.create_table(channel, t, data[t])
				elif t not in tables:
					continue
				# The target table exists. Check the columns.
				columns = self.show_columns(channel, t)
				#print('columns:', columns, 'data', datacolumns);
				for column in columns:
					if column not in datacolumns:
						if remove:
							db.write('ALTER TABLE {} DROP COLUMN {}'.format(self._mktable(channel, t), column))
						else:
							print('obsolete column %s in table %s for channel %s' % (column, t, channel), file = sys.stderr)
				desc = self._show_columns(channel, t)	# Get column descriptions to know if a primary key is defined.
				for column in datacolumns:
					if column not in columns:
						if add:
							coldesc = datacolumns[column]
							if (' PRIMARY KEY' in coldesc and	# The new column is the primary key.
									(column not in desc or ' PRIMARY KEY' not in desc[column]) and	# The column does not exist yet, or is not the primary key yet.
									any(' PRIMARY KEY' in desc[x] for x in desc)):	# There is a primary key in the current table.
								db.write('ALTER TABLE {} DROP PRIMARY KEY'.format(self._mktable(channel, t)))
							elif ' PRIMARY KEY' in datacolumns[column] and column in desc and ' PRIMARY KEY' in desc[column]:
								coldesc = coldesc.replace(' PRIMARY KEY', '')
							db.write('ALTER TABLE {} ADD {} {}'.format(self._mktable(channel, t), column, coldesc))
						else:
							print('extra column %s defined in table %s for channel %s' % (column, t, channel), file = sys.stderr)
							continue
				desc = self._show_columns(channel, t)	# Get column descriptions including newly created columns.
				for column in desc:
					if column not in datacolumns:
						continue
					if desc[column] != datacolumns[column]:
						if add:
							coldesc = datacolumns[column]
							if ' PRIMARY KEY' in datacolumns[column] and (column not in desc or ' PRIMARY KEY' not in desc[column]) and any(' PRIMARY KEY' in x for x in desc):
								db.write('ALTER TABLE {} DROP PRIMARY KEY'.format(self._mktable(channel, t)))
							elif ' PRIMARY KEY' in datacolumns[column] and column in desc and ' PRIMARY KEY' in desc[column]:
								coldesc = coldesc.replace(' PRIMARY KEY', '')
							db.write('ALTER TABLE {} MODIFY COLUMN {} {}'.format(self._mktable(channel, t), column, coldesc))
				desc = self._show_columns(channel, t)	# Get column descriptions including newly modified columns.
				for column in desc:
					if column not in datacolumns:
						continue
					if desc[column] != datacolumns[column]:
						print('db column description "%s" does not match definition "%s" for table %s of channel %s.' % (desc[column], datacolumns[column], t, channel), file = sys.stderr)
	# }}}
# }}}

class Settings(Connection_Base): # {{{
	# This is a logged in player (managed or external) changing their settings.
	def __init__(self, remote): # {{{
		super().__init__(remote)
		settingses = remote.data['query']['settings']
		if len(settingses) != 1:
			print('invalid settingses in query string', file = sys.stderr)
			remote._websocket_close()
			return
		self.dcid = settingses[0]
		if self.dcid not in active_player:
			print('invalid dcid in query string for settings: %s (not in %s)' % (self.dcid, ', '.join(active_player)), file = sys.stderr)
			remote._websocket_close()
			return
		settings = self.get_player_settings()
		remote.update_settings.event(settings)
	# }}}

	def get_player_settings(self): # {{{
		'Return current settings (name and language; not password)'
		if self.assertion(self.dcid in active_player):
			return
		record = active_player[self.dcid]
		if self.assertion(record['game'].is_game(record['channel'])):
			return
		game = record['game'].channel[record['channel']]
		if record['gcid'] is None:
			# External player.
			player = db.find_player(game['user'], game['url'], record['name'])
			return {'loginname': player['name'], 'fullname': player['fullname'], language: player['language']}
		else:
			# Local player.
			managed = db.find_managed(game['game']['id'], record['name'])
			return {'loginname': record['name'], 'fullname': managed['name'], 'language': managed['language']}
	# }}}

	def set_player_settings(self, name = None, language = None, password = None): # {{{
		'Set new name and language, and for managed players, also password'
		if self.assertion(self.dcid in active_player):
			return
		record = active_player[self.dcid]
		if self.assertion(record['game'].is_game(record['channel'])):
			return
		game = record['game'].channel[record['channel']]
		if record['gcid'] is None:
			# External player.
			if self.assertion(password is None):
				return
			player = db.find_player(game['user'], game['url'], record['name'])
			db.setup_update_player(player['id'], game['user'], game['url'], record['name'], name if name is not None else player['name'], language if language is not None else record['language'], record['is_default'])
		else:
			# Local player.
			managed = db.find_managed(game['game']['id'], record['name'])
			db.setup_update_managed_player(managed['id'], game['game']['id'], record['name'], name if name is not None else managed['name'], language if language is not None else managed['language'], managed['email'], password)
		settings = self.get_player_settings()
		self.remote.update_settings.event(settings)

		# TODO: Send update to other connections.
	# }}}
# }}}

def select_connection(remote):
	#print(remote.data)
	if 'settings' in remote.data['query']:
		return Settings(remote)
	else:
		return Connection(remote)

if config['list']:	# Show list of items in database. {{{
	users = db.setup_list_users()
	for u in users:
		print('User id: %x; name: %s; fullname: %s; e-mail: %s' % (u['id'], u['name'], u['fullname'], u['email']))
		players = db.setup_list_players(u['id'])
		if len(players) == 0:
			print('\tNo external players')
		for p in players:
			print('\tExternal player id: %x; name: %s; fullname: %s; url: %s; default: %s' % (p['id'], p['name'], p['fullname'], p['url'], ('yes' if p['is_default'] else 'no')))
		games = db.setup_list_games(u['id'])
		if len(games) == 0:
			print('\tNo games')
		for g in games:
			print('\tGame id: %x; name: %s; fullname: %s' % (g['id'], g['name'], g['fullname']))
			players = db.setup_list_managed_players(g['id'])
			if len(players) == 0:
				print('\tNo managed players')
			for p in players:
				print('\t\tManaged player id: %x; name: %s; fullname: %s; e-mail: %s' % (p['id'], p['name'], p['fullname'], p['email']))
# }}}


server = websocketd.RPChttpd(config['port'], select_connection, httpdirs = ('html',))
server.games = {}
server.player = {}
print('server is running on port %s' % config['port'])

while True:
	try:
		websocketd.fgloop()
	except ValueError:
		print('ignoring exception: %s' % str(sys.exc_info()[1]))

# vim: set foldmethod=marker :
