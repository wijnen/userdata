#!/usr/bin/python3
# userdata: system for user authentication and data storage.
# This is the server program, which manages the data.

'''
Interface: {{{

Terminology:
	- user: human owner of managed data.
	- player: human person to who the managed data applies, who may or may not also be the owner of that data.
	- browser: program through which users and players interact with their game server and the userdata server.
	- userdata server: this program, it manages the data for several users and several games.
	- game server: a program that provides a game interface to players and connects to one or more userdata servers to store its data.
	- token: a cryptographically hard to guess string that allows access to a user's data. The user receives it after logging in and should pass it to the game server.

Game protocol:
	- login_game()		At boot, the game server connects to its userdata to store game data. This also allows access to all data from players stored under that user.
	-			When a player connects to the game, a userdata server is selected based on the game settings (with/without default; allow-local, allow-external)
	- login_{user,player}()	Player connects to userdata and logs in, receiving a token
	-			Browser notifies game server that login was successful and which userdata was used, plus an access token.
	- login_token()		Game server connects to the userdata (or uses existing connection) and provides the token
	-			Game server uses the connection to handle player data.

Data management protocol:
	- Option 1: User connects directly to userdata and logs in
	- Option 2: User logs in through a game that allows external userdata, then selects "manage data".
	Both options need login_user() to be used. login_player() does not allow access to the data.
	Data management browser interface still needs to be designed.
	Alternatively, when logging in through a program, regular database commands can be used.

Possible connections to userdata server (this program):

From game:	self.game = (game_id, ...); self.user = username or None; self.manage = False
	- login_game(game_info, name = None, password = None): set game info for login_token; use game data if credentials are supplied. Set self.game = game_info
	- login_token(token, player_id): return player name; use data for player that provided the token. Login_game must always be called first; this can be called multiple times to share the connection for multiple players. Set self.player[id] = (username, None) or (username, playername)
	- logout(player_id): Remove player from list of accessible data.
	- [db_access](game_id, player_id, ...): All db access uses the player id as first argument. It should be set to None for the game data.

From user:	self.game = None; self.user = username; self.manage = True
	- login_user(name, password): manage user data; full access. Set self.user = name.
	- list_games(): return all games that have data (index in this list is the game_id for this connection)
	- list_players(game_id): return all valid players (stored under this user) for the game.
	- [db_access](game_id, player_id, ...): same interface as from game

From player:	self.game = None; self.user = username; self.player = playername or None; self.manage = False
	- login_user(name, password, game_info): return token. Connection is closed when game provides token. Token is invalidated if this connection is closed before it is used. This connection can be used for data management until the token is used. Set server.player[token] = self.
	- login_player(username, playername, password, game_info): return token; same as above, use player account inside user's data. Set server.player[token] = self.

Database format:

All tables have a prefix if set on the commandline using --prefix.
User tables have an additional (after the global prefix) prefix of 'username-gamename-playername-'.
The [gamename]-prefix is the [game1]-field in the user table (not the id provided by the game itself).
For game data and for login_user()-data, playername is "". In other words, the prefix is 'username-gamename--'.
The userdata server never changes user tables except as asked by authorized users.
Internal data is (all tables have the global prefix):
	user: name, game_id, game1, game2, password, email	(if game1 is NULL, this is the master login for the user.)
	[username]-[gamename]-user: name, password, email

}}}
'''

# Imports and config. {{{
import sys
import secrets
import websocketd
import db
import re
import fhs
fhs.option('port', 'Port to listen on for game server requests', default = '8879')
fhs.option('authport', 'Port to listen on for authentication requests; leave empty for same as game server requests', default = '')
fhs.option('prefix', 'Prefix to use for all database tables', default = '')
fhs.option('allow-new-users', 'Allow new users to register', argtype = bool)
fhs.option('url', 'override url for auth host (defaults to same as connect host)', default = '')
config = fhs.init(contact = 'Bas Wijnen <wijnen@debian.org>', help = 'Server for handling user data', version = '0.1')
prefix = config['prefix']

if len(sys.argv) != 1:
	print('non-option arguments are ignored', file = sys.stderr)
# }}}

# Pending login requests (key is token, value is requesting server Connection object)
pending = {}

def _assert_is_id(name): # {{{
	'Check that a name is a valid id (mostly to protect against injections)'
	assert isinstance(name, str)
	assert re.match('^[a-zA-Z_][a-zA-Z_0-9]*$', name)
# }}}

def mangle_name(self, name): {{{
	# TODO: actually mangle instead of refusing.
	_assert_is_id(name)
	return name
# }}}

class Connection: # {{{
	'''This connection is opened by the game directly, or by the player
	through a login url. It may be used to authenticate directly, if the
	game is trusted by the owner of the userdata account (and therefore can
	present the credentials), or it can request a link for letting the user
	log in.
	'''
	def __init__(self, remote): # {{{
		self.remote = remote
		self.game_id = None	# set after login_game: game id that this connection is about.
		self.game = None	# set after login_player: game object that owns the player.
		self.user = None	# set after login_user or login_game.
		self.player = {}	# user name and/or player name for connection from game. Key is game-provided id; value is (username, playername or None).
		self.manage = False
		self.gametoken = None
		self.token = None
	# }}}

	def _mktable(self, player, table, game): # {{{
		'Create SQL table name'
		return prefix + self.userprefix + self.gameprefix[game] + self.playerprefix + table
	# }}}

	def _try_login(self, user, password, game_id): # {{{
		# XXX: allow using public key authentication instead of password.
		# Possibly not a good idea, because it suggests better protection than what is provided.
		# (Iow: when doing that, also move to using that key for encrypting all communication.)
		assert game_id is None or isinstance(game_id, str)
		assert isinstance(user, str) and isinstance(password, str)
		name = mangle_name(user)
		gameprefix = db.authenticate(name, password, game_id, prefix + 'user')
		if gameprefix is None:
			raise PermissionError('Authentication failed.')
		self.user = name
		self.userprefix = self.user + '-'
		self.gameprefix = gameprefix
	# }}}

	def login_game(self, game_info, user = None, password = None): # {{{
		'Game logs in without player interaction.'
		assert self.gametoken = None
		assert isinstance(game_info, dict) and 'id' in game_info and isinstance(game_info['id'], str)
		if user is not None:
			self._try_login(user, password, game_info['id'])
			if len(self.gameprefix) > 0:
				self.gametoken = secrets.token_urlsafe()
				while self.gametoken in running_games:
					self.gametoken = secrets.token_urlsafe()
				running_games[self.gametoken] = self
		self.game = game_info
		return (config['url'] or self.remote.data['url']), self.gametoken
	# }}}

	def login_user(self, user, password, game_info = None): # {{{
		'User logs in. Return token and allow data management.'
		assert self.token is None
		assert game_info is None or (isinstance(game_info, dict) and 'id' in game_info and isinstance(game_info['id'], str))
		self._try_login(user, password, game_info['id'])
		self.game = game_info
		self.token = secrets.token_urlsafe()
		while self.token in pending:
			self.token = secrets.token_urlsafe()
		pending[self.token] = self
		return (config['url'] or self.remote.data['url']), self.token
	# }}}

	def login_player(self, gametoken, player, password): # {{{
		"Player (stored under user's data) logs in. User is identified through token (received from login_game), to protect privacy."
		assert gametoken in running_games
		game = running_games[gametoken]
		if not db.authenticate(name, password, None, prefix + game.userprefix + game.gameprefix[0] + '-user'):
			raise PermissionError('Authentication failed.')
		self.token = secrets.token_urlsafe()
		while self.token in pending:
			self.token = secrets.token_urlsafe()
		pending[self.token] = self
		self.game = game
		self.player = player
		return (config['url'] or self.remote.data['url']), self.token
	# }}}

	def login_token(self, token, player_id): # {{{
		'Game finalizes login by providing token.'
		pass
	# }}}

	def request_login_url(self, player_id): # {{{
		'Present game info; retrieve auth url'
		assert player_id not in self.auth_token
		self.auth_token[player_id] = None
		while self.auth_token[player_id] is None or self.auth_token[player_id] in pending:
			self.auth_token[player_id] = secrets.token_urlsafe()
		pending[self.auth_token[player_id]] = (self, player_id)
		return (config['url'] or self.remote.data['url']) + '?token=' + self.auth_token[player_id]
	# }}}

	def wait_for_login(self, player_id): # {{{
		'Wait for login to complete. If already logged in, return immediately.'
		wake = (yield)
		if self.user is not None:
			return None
		self._logged_in[player_id] = wake
		yield
		if self.user is not None:
			return None
		return 'Login failed: Connection lost'
	# }}}

	# Database access. {{{
	def create_table(self, player, table, columns): # {{{
		assert self.user is not None
		for c in columns:
			_assert_is_id(c)
		db.write('CREATE TABLE %s (%s)' % (self._mktable(player, table), ', '.join('%s %s' % c for c in columns)))
	# }}}

	def drop_table(self, player, table): # {{{
		assert self.user is not None
		db.write('DROP TABLE %s' % (self._mktable(player, table)))
	# }}}

	def insert(self, player, table, data): # {{{
		assert self.user is not None
		if isinstance(data, dict):
			data = [(k, v) for k, v in data.items()]
		for d in data:
			_assert_is_id(d[0])
		db.write('INSERT INTO %s (%s) VALUES (%s)' % (self._mktable(player, table), ', '.join(d[0] for d in data), ', '.join('%s' for d in data)), *tuple(d[1] for d in data))
	# }}}

	def delete(self, player, table, condition): # {{{
		assert self.user is not None
		c = self._parse_condition(condition)
		db.write('DELETE FROM %s%s' % (self._mktable(player, table), c[0]), *c[1])
	# }}}

	def update(self, player, table, data, condition): # {{{
		assert self.user is not None
		c = self._parse_condition(condition)
		if isinstance(data, dict):
			data = [(k, v) for k, v in data.items()]
		columns = tuple(d[0] for d in data)
		values = tuple(d[1] for d in data)
		for c in columns:
			_assert_is_id(c)
		db.write('UPDATE %s SET %s%s' % (self._mktable(player, table), ', '.join('%s = %%s' % columns), c[0]), values + c[1])
	# }}}

	def select(self, player, columns, table, condition): # {{{
		assert self.user is not None
		for c in columns:
			_assert_is_id(c)
		c = self._parse_condition(condition)
		return db.read('SELECT %s FROM %s%s' % (', '.join(columns), self._mktable(player, table), c[0]), *c[1])
	# }}}

	def _parse_condition(self, condition): # {{{
		'''Parse a condition argument.
		Argument is an RPN expression tree.
		Nodes are ('and' | 'or' | 'not', branch1, branch2) (branch2 is omitted for not)
		Leaves are ('=' | '>' | '<' | '>=' | '<=' | '<>' | 'like', column, value)
		Return a 2-tuple, with the string in the query as the first item and the arguments as the second.
		'''
		# XXX: support more complex conditions.
		if len(condition) == 0:
			return ('', ())
		if condition[0] not in ('=', '<', '>', '<=', '>=', '<>', 'like'):
			raise NotImplementedError('Only simple conditions are supported at the moment')
		_assert_is_id(condition[1])
		return (' WHERE ' + condition[1] + ' ' + condition[0].upper() + ' %s', (condition[2],))
	# }}}
	# }}}
# }}}

server = websocketd.RPChttpd(config['port'], Connection, httpdirs = ('html',))
server.player = {}
print('server is running')

websocketd.fgloop()

# vim: set foldmethod=marker :
