#!/usr/bin/python3
# userdata: system for user authentication and data storage.
# This is the server program, which manages the data.

# XXX: allow using public key authentication instead of password.
# Possibly not a good idea, because it suggests better protection than what is provided.
# (Iow: when doing that, also move to using that key for encrypting all communication.)

'''
Interface: {{{

Summary:

This program provides access to data for users and games.
The data is organized as:
- administrative: user names, passwords
	user: name, game_id, games, password, email	(if games is NULL, this is the master login for the user; otherwise it is a tab-separated list of games (in a string))
- per user and per game:
	- admin data for managed players
		username-gamename-player: name, password, email
	- other data for managed players
		username-gamename-playername-*: any format
	- other data for game, or for player owner in possibly remote game
		username-gamename--*: any format

Terminology:
	- user: human owner of managed data.
	- player: human person to who the managed data applies, who may or may not also be the owner of that data.
	- browser: program through which users and players interact with their game server and the userdata server.
	- userdata server: this program, it manages the data for several users and several games.
	- game server: a program that provides a game interface to players and connects to one or more userdata servers to store its data.
	- token: a cryptographically hard to guess string that allows access to a user's data. The user receives it after logging in and should pass it to the game server.

Game protocol, option 0: all data owned by game; no player logins:
	- game -> userdata: login_game()
	- game -> userdata: select() etc.

Game protocol, option 1: player data is not owned by the game:
	- game -> userdata: login_game()	At boot, the game server connects to its userdata to store game data.
	-		When a player connects to the game, a userdata server is selected based on the game settings (with/without default; allow-local, allow-external)
	- player -> userdata: login_user()	Player connects to userdata and logs in, receiving a token
	- player -> game: Browser notifies game server that login was successful and which userdata was used, plus an access token.
	- game -> userdata: login_token()
	- game -> userdata: select etc.

Game protocol, option 2: player data is owned by the game:
	- game -> userdata: login_game()		Same as above
	- 			When a player connects to the game, a login link for the local userdata is sent to it.
	- game -> userdata: get_token()
	- player -> userdata: login_player()	Player connects to userdata using the link (which includes a token)
	- player -> game: Browser notifies game server that login was successful, including a credentials token
	- game -> userdata: veryify_player()	Check if token is a valid login

Data management protocol:
	- Option 1: User connects directly to userdata and logs in
	- Option 2: User logs in through a game that allows external userdata, then selects "manage data".
	Both options need login_user() to be used. login_player() does not allow access to the data.
	Data management browser interface still needs to be designed.
	Alternatively, when logging in through a program, regular database commands can be used.

Possible connections to userdata server (this program):

From game:	self.game = (game_id, ...); self.user = username or None; self.manage = False
	- login_game(game_info, name = None, password = None): set game info for login_token; use game data if credentials are supplied. Set self.game = game_info
	- login_token(token, player_id): return player name; use data for player that provided the token. Login_game must always be called first; this can be called multiple times to share the connection for multiple players. Set self.player[id] = (username, None) or (username, playername)
	- logout(player_id): Remove player from list of accessible data.
	- [db_access](game_id, player_id, ...): All db access uses the player id as first argument. It should be set to None for the game data.

From user:	self.game = None; self.user = username; self.manage = True
	- login_user(name, password): manage user data; full access. Set self.user = name.
	- list_games(): return all games that have data (index in this list is the game_id for this connection)
	- list_players(game_id): return all valid players (stored under this user) for the game.
	- [db_access](game_id, player_id, ...): same interface as from game

From player:	self.game = None; self.user = username; self.player = playername or None; self.manage = False
	- login_user(name, password, game_info): return token. Connection is closed when game provides token. Token is invalidated if this connection is closed before it is used. This connection can be used for data management until the token is used. Set server.player[token] = self.
	- login_player(username, playername, password, game_info): return token; same as above, use player account inside user's data. Set server.player[token] = self.

Database format:

All tables have a prefix if set on the commandline using --prefix.
User tables have an additional (after the global prefix) prefix of 'username-gamename-playername-'.
The [gamename]-prefix is the [game1]-field in the user table (not the id provided by the game itself).
For game data and for login_user()-data, playername is "". In other words, the prefix is 'username-gamename--'.
The userdata server never changes user tables except as asked by authorized users.
Internal data is (all tables have the global prefix):
	user: name, game_id, games, password, email
		If game_id is NULL, this is the master login for the user and games is NULL; email is the email address of the user.
		Otherwise games is a tab-separated list of games (in a string); email is the name to use for referring to the game in an email about it.
	[username]-[gamename]-user: name, password, email

}}}
'''

# Imports and config. {{{
import sys
import secrets
import websocketd
import db
import re
import fhs
fhs.option('port', 'Port to listen on for game server requests', default = '8879')
fhs.option('authport', 'Port to listen on for authentication requests; leave empty for same as game server requests', default = '')
fhs.option('prefix', 'Prefix to use for all database tables', default = '')
fhs.option('allow-new-users', 'Allow new users to register', argtype = bool)
fhs.option('url', 'override url for auth host (defaults to same as connect host)', default = '')
config = fhs.init(contact = 'Bas Wijnen <wijnen@debian.org>', help = 'Server for handling user data', version = '0.1')
prefix = config['prefix']

if len(sys.argv) != 1:
	print('non-option arguments are ignored', file = sys.stderr)
# }}}

# Pending login requests (key is token, value is dict {'connection': object, 'player': player, 'user_id': user_id})
pending_player_login = {}

def _assert_is_id(name): # {{{
	'Check that a name is a valid id (mostly to protect against injections)'
	assert isinstance(name, str)
	assert re.match('^[a-zA-Z_][a-zA-Z_0-9]*$', name)
# }}}

def mangle_name(name):	# {{{
	'Return name with special characters replaced such that it is a valid id.'
	ret = ''
	for x in name:
		if 'a' <= x <= 'z' or 'A' <= x <= 'Z' or '0' <= x <= '9':
			ret += x
		elif x == '_':
			ret += '__'
		else:
			ret += '_%02x' % ord(x)
	# Sanity check.
	_assert_is_id(ret)
	return ret
# }}}

def make_token(container):	# {{{
	'Generate a cryptographically hard to guess token that is not present in the container dict'
	token = secrets.token_urlsafe()
	while token in container:
		token = secrets.token_urlsafe()
	return token
# }}}

class Connection: # {{{
	'''This connection is opened by the game directly, or by the player
	through a login url. It may be used to authenticate directly, if the
	game is trusted by the owner of the userdata account (and therefore can
	present the credentials), or it can request a link for letting the user
	log in.
	'''
	def __init__(self, remote): # {{{
		self.remote = remote

		# Users that are logged in on this connection.
		# Keys are user_ids given as arguments to login_*.
		# Values are dicts with fields:
		# - 'user': user prefix for the database. Always ends in '-'.
		# - 'manage': bool, if True this connection can be used to add, remove and modify games and players for this user.
		# - 'token': token for passing access to another connection, or None; stored in pending_user_token.
		# - 'game': sequence of game dicts. DB access takes an index into this sequence.
		#	- 'prefix': db prefix for this game.
		#	- 'token': token for logging players into this game, or None; stored in pending_player_login.
		self.user = {}

		# Register cleanup function.
		remote.closed = self._closed

		# Handle token parameter. # FIXME
		if 'token' in remote.data['query']:
			tokens = remote.data['query']['token']
			if len(tokens) != 1:
				print('invalid tokens in query string', file = sys.stderr)
				remote.close()
				return
			self.token = tokens[0]
			if self.token not in pending_player_login:
				print('invalid token in query string', file = sys.stderr)
				remote.close()
				return
		else:
			self.token = None
	# }}}

	def login_game(self, user_id, user_name, password, game_id): # {{{
		assert user_id not in self.user
		name = mangle_name(user_name)
		# Verify credentials
		games = db.authenticate(name, password, game_id, prefix + 'user')
		# Record permissions
		self.user[user_id] = {'prefix': name + '_', 'games': games}
	# }}}

	def _closed(self):	# {{{
		'''Clean up registered tokens.'''
		pass
	# }}}

	def _mktable(self, user_id, table, player = None, game = 0): # {{{
		'Create SQL table name'
		games = self.user[user_id]['games']
		if games is not None:
			assert 0 <= game <= len(games)
			game = games[game]
		if player is None:
			playerprefix = ''
		else:
			playerprefix = player
		return prefix + self.user[user_id]['prefix'] + game + '_' + playerprefix + '_' + table
	# }}}

	def request_login_link(self, user_id, player, game = 0): # {{{
		assert user_id in self.user
		assert player is not None
		assert player not in self.user[user_id]['pending_token']
		token = make_token(pending_player_login)
		pending_player_login[token] = {'connection': self, 'player': player, 'user_id': user_id}
		self.user[user_id]['pending_token'][player] = token
		return (config['url'] or self.remote.data['url']) + '?token=' + token
	# }}}

	def revoke_login_link(self, user_id, player, game = 0): # {{{
		assert user_id in self.user
		assert player is not None
		if player in self.user[user_id]['pending_token']:
			del pending_player_login[self.user[user_id]['pending_token'][player]]
			del self.user[user_id]['pending_token'][player]
		else:
			assert player in self.user[user_id]['pending_player']
			del self.user[user_id]['pending_player'][player]
	# }}}

	def verify_player_login(self, user_id, player, game = 0): # {{{
		assert user_id in self.user
		assert player is not None
		if player in self.user[user_id]['pending_token']:
			return None
		assert player in self.user[user_id]['pending_player']
		p = self.user[user_id]['pending_player'].pop(player)
		p['wake']()
		return p['name']
	# }}}
	""" {{{
	def login_user(self, user_id, user_name, password): # {{{
		'User logs in. Return token and allow data management.'
		assert isinstance(user_name, str) and isinstance(password, str)
		assert user_id not in self.user
		name = mangle_name(user_name)
		games = db.authenticate(name, password, None, prefix + 'user')
		assert games is None
		self.user[user_id] = {'prefix': name + '_', 'games': None}
	# }}}

	def revoke_login_url(self, user_id, game_idx): # {{{
		# FIXME
		token = self.users[user_id]['game'][game_idx]['token']
		assert token is not None
		del pending_player_login[token]
		self.users[user_id]['game'][game_idx]['token'] = None
	# }}}

	def get_login_url(self, user_id, game_idx): # {{{
		# FIXME
		'''Return an url where players stored under this user can log in.'''
		assert user_id in self.users
		token = self.users[user_id]['game'][game_idx]['token']
		if token is not None:
			self.revoke_login_url(user_id, game_idx)
		token = make_token(pending_player_login)
		self.users[user_id]['game'][game_idx]['token'] = token
		pending_player_login[token] = {'connection': self, 'game': game_idx, 'user': user_id}
		return (config['url'] or self.remote.data['url']) + '?token=' + token
	# }}}

	def login_player(self, player, password): # {{{
		"Player (stored under user's data) logs in. User is identified through token (received from login_game), to protect privacy."
		# FIXME
		assert self.token in pending_player_login
		obj = pending_player_login[self.token]
		connection = obj['connection']
		game_idx = obj['game']
		user = obj['user']
		user_obj = connection.users[user]
		user_prefix = user_obj['user']
		game_obj = user_obj['game'][game_idx]
		game_prefix = game_obj['prefix']
		if not db.authenticate_player(player, password, None, prefix + user_prefix + game_prefix + 'user'):
			raise PermissionError('Authentication failed.')
		player_token = make_token(game_obj['logins'])
		game_obj['logins'][player_token] = (self, player)
		return player_token
	# }}}

	def verify_player(self, user_id, game_idx, token): # {{{
		'''Accept player login; close login connection and return player name.'''
		# FIXME
		game = self.users[user_id]['game'][game_idx]
		assert token in game['logins']
		connection, player = game['logins'].pop(token)
		connection.close()
		return player
	# }}}

	def make_login_token(self, user_id): # {{{
		'''Return a token which can be passed to a game to prove that this connection has logged in.'''
		# FIXME
		assert user_id in self.users
		if self.users[user_id]['token'] is not None:
			self.revoke_login_token(user_id)
		token = make_token(pending_user_token)
		pending_user_token[token] = (self, user_id)
		self.users[user_id]['token'] = token
		return token
	# }}}

	def revoke_login_token(self, user_id): # {{{
		# FIXME
		token = self.users[user_id]['token']
		assert token is not None
		del pending_user_token[token]
		self.users[user_id]['token'] = None
	# }}}

	def login_token(self, user_id, token): # {{{
		'Game finalizes login by providing token.'
		# FIXME
		assert token in pending_user_token
		connection, remote_id = pending_user_token[token]
		connection.revoke_login_token(remote_id)
		self.users[user_id] = connection.users[remote_id]
	# }}}
	}}}"""

	# Database access. {{{
	def show_tables(self, user_id, player = None, game = 0): # {{{
		assert user_id in self.user
		if self.user[user_id]['games'] is None and game is None:
			p = prefix + self.user[user_id]['prefix']
			ret = {}
			for x in db.read1('SHOW TABLES'):
				if not x.startswith(p):
					continue
				game, t = x[len(p):].split('_', 1)
				if game not in ret:
					ret[game] = []
				ret[game].append(t)
			return ret
		else:
			p = self._mktable(user_id, '', player, game)
			return [x[len(p):] for x in db.read1('SHOW TABLES') if x.startswith(p)]
	# }}}

	def create_table(self, user_id, table, columns, player = None, game = 0): # {{{
		assert user_id in self.user
		if isinstance(columns, dict):
			columns = [(k, v) for k, v in columns.items()]
		for c in columns:
			_assert_is_id(c[0])
		db.write('CREATE TABLE %s (%s)' % (self._mktable(user_id, table, player, game), ', '.join('%s %s' % tuple(c) for c in columns)))
	# }}}

	def drop_table(self, user_id, table, player = None, game = 0): # {{{
		assert user_id in self.user
		db.write('DROP TABLE %s' % (self._mktable(user_id, table, player, game)))
	# }}}

	def insert(self, user_id, table, data, player = None, game = 0): # {{{
		assert user_id in self.user
		if isinstance(data, dict):
			data = [(k, v) for k, v in data.items()]
		for d in data:
			_assert_is_id(d[0])
		db.write('INSERT INTO %s (%s) VALUES (%s)' % (self._mktable(user_id, table, player, game), ', '.join(d[0] for d in data), ', '.join('%s' for d in data)), *tuple(d[1] for d in data))
	# }}}

	def delete(self, user_id, table, condition, player = None, game = 0): # {{{
		assert user_id in self.user
		c = self._parse_condition(condition)
		db.write('DELETE FROM %s%s' % (self._mktable(user_id, table, player, game), c[0]), *c[1])
	# }}}

	def update(self, user_id, table, data, condition, player = None, game = 0): # {{{
		assert user_id in self.user
		c = self._parse_condition(condition)
		if isinstance(data, dict):
			data = [(k, v) for k, v in data.items()]
		columns = tuple(d[0] for d in data)
		values = tuple(d[1] for d in data)
		for col in columns:
			_assert_is_id(col)
		db.write('UPDATE %s SET %s%s' % (self._mktable(user_id, table, player, game), ', '.join('%s = %%s' % col for col in columns), c[0]), values + c[1])
	# }}}

	def select(self, user_id, table, columns, condition = (), player = None, game = 0): # {{{
		assert user_id in self.user
		if isinstance(columns, str):
			columns = (columns,)
		for c in columns:
			_assert_is_id(c)
		c = self._parse_condition(condition)
		return db.read('SELECT %s FROM %s%s' % (', '.join(columns), self._mktable(user_id, table, player, game), c[0]), *c[1])
	# }}}

	def _parse_condition(self, condition): # {{{
		'''Parse a condition argument.
		Argument is an RPN expression tree.
		Nodes are ('and' | 'or' | 'not', branch1, branch2) (branch2 is omitted for not)
		Leaves are ('=' | '>' | '<' | '>=' | '<=' | '<>' | 'like', column, value)
		Return a 2-tuple, with the string in the query as the first item and the arguments as the second.
		'''
		# XXX: support more complex conditions.
		if len(condition) == 0:
			return ('', ())
		if condition[0] not in ('=', '<', '>', '<=', '>=', '<>', 'like'):
			raise NotImplementedError('Only simple conditions are supported at the moment')
		_assert_is_id(condition[1])
		return (' WHERE ' + condition[1] + ' ' + condition[0].upper() + ' %s', (condition[2],))
	# }}}
	# }}}

	def setup_db(self, user_id, data, player = None, game = 0, remove = True, add = True, replace = False): # {{{
		'Create tables of columns'
		assert user_id in self.user
		tables = self.show_tables(user_id, player, game)
		if remove or replace:
			for t in tables:
				if replace or (remove and t not in data):
					self.drop_table(user_id, t, player, game)
		if add:
			for t in data:
				if replace or t not in tables:
					self.create_table(user_id, t, data[t], player, game)
	# }}}
# }}}

server = websocketd.RPChttpd(config['port'], Connection, httpdirs = ('html',))
server.player = {}
print('server is running on port %s' % config['port'])

websocketd.fgloop()

# vim: set foldmethod=marker :
