#!/usr/bin/python3
# userdata: system for user authentication and data storage.
# This is the server program, which manages the data.

# XXX: allow using public key authentication instead of password.
# Possibly not a good idea, because it suggests better protection than what is provided.
# (Iow: when doing that, also move to using that key for encrypting all communication.)

'''
Interface: {{{

Summary:

This program provides access to data for users and games.
The data is organized as:
- administrative: user names, passwords
	user: name, game, containers, password, email	(if containers is NULL, this is the master login for the user; otherwise it is a tab-separated list of containers (in a string))
- per user and per container:
	- admin data for managed players
		username-containername-player: name, password, email
	- other data for managed players
		username-containername-playername-*: any format
	- other data for container, or for player owner in possibly remote game
		username-containername--*: any format

Terminology:
	- user: human owner of managed data.
	- player: human person to who the managed data applies, who may or may not also be the owner of that data.
	- browser: program through which users and players interact with their game server and the userdata server.
	- userdata server: this program, it manages the data for several users and several containers.
	- game server: a program that provides a game interface to players and connects to one or more userdata servers to store its data.
	- token: a cryptographically hard to guess string that allows access to a user's data. The user receives it after logging in and should pass it to the game server.

Game protocol, option 0: all data owned by game; no player logins:
	- game -> userdata: login_game()
	- game -> userdata: select() etc.

Game protocol, option 1: player data is not owned by the game:
	- game -> userdata: login_game()        At boot, the game server connects to its userdata to store game data.
	- game -> player: token()       Game provides token to player at connect; game settings are passed as argument.
	-		When a player connects to the game, a userdata server is selected based on the game settings (with/without default; allow-local, allow-external)
	- player -> userdata: login_user()      Player connects to userdata and logs in
	- player -> userdata: connect()         Player instructs userdata to connect to game, passing game url and token
	- userdata -> game: connect           Userdata connects to game, passing token
	- player -> game: connect()     Player waits for connection to complete; this call blocks until userdata connection is established.
	- game -> userdata: select etc.

Game protocol, option 2: player data is owned by the game:
	- game -> userdata: login_game()                Same as above
	- game -> userdata: create_token()      Allow players to log in on this game; this token is encoded in the url given to players.
	- game -> player: token()       Game provides token to player at connect; game settings are passed as argument.
	-		When a player connects to the game, a userdata server is selected based on the game settings (with/without default; allow-local, allow-external)
	- player -> userdata: login_player()    Player connects to local userdata and logs in, passing token
	- userdata -> game: connect()           Userdata passes token to game
	- game -> userdata: select etc.

Data management protocol:
	- Option 1: User connects directly to userdata and logs in
	- Option 2: User logs in through a game that allows external userdata, then selects "manage data".
	Both options need login_user() to be used. login_player() does not allow access to the data.
	Data management browser interface still needs to be designed.
	Alternatively, when logging in through a program, regular database commands can be used.

Possible connections to userdata server (this program):

From game:	self.game = (game, ...); self.user = username or None; self.manage = False
	- login_game(player_id, game_info, name = None, password = None): set game info for login_token; use game data if credentials are supplied. Set self.game = game_info
	- logout(player_id): Remove player from list of accessible data.
	- [db_access](game, player_id, ...): All db access uses the player id as first argument. It should be set to None for the game data.

From user:	self.game = None; self.user = username; self.manage = True
	- login_user(name, password): manage user data; full access. Set self.user = name.
	- list_games(): return all games that have data (index in this list is the game for this connection)
	- list_players(game): return all valid players (stored under this user) for the game.
	- [db_access](game, player_id, ...): same interface as from game

From player:	self.game = None; self.user = username; self.player = playername or None; self.manage = False
	- login_user(name, password, game_info): return token. Connection is closed when game provides token. Token is invalidated if this connection is closed before it is used. This connection can be used for data management until the token is used. Set server.player[token] = self.
	- login_player(username, playername, password, game_info): return token; same as above, use player account inside user's data. Set server.player[token] = self.

Database format:

All tables have a prefix if set on the commandline using --prefix.
User tables have an additional (after the global prefix) prefix of 'username-containername-playername-'.
The [containername]-prefix is the [container1]-field in the user table (not the id provided by the game itself).
For game data and for login_user()-data, playername is "". In other words, the prefix is 'username-containername--'.
The userdata server never changes user tables except as asked by authorized users.
Internal data is (all tables have the global prefix):
	user: name, password, email
		list of recognized users
	[username]-games: name
		list of games for this user
	[username]-user: game, password, container_name, games
		list of valid game logins for this user. game is passed on login. container_name is used when communicating, such as in emails. containers is a tab-separated list of accessible databases.
	[username]-[containername]-player: name, password, email
		list of managed players for this game

}}}
'''

# Imports and config. {{{
import sys
import secrets
import urllib
import websocketd
import db
import re
import fhs
fhs.option('port', 'Port to listen on for game server requests', default = '8879')
fhs.option('authport', 'Port to listen on for authentication requests; leave empty for same as game server requests', default = '')
fhs.option('prefix', 'Prefix to use for all database tables', default = '')
fhs.option('allow-new-users', 'Allow new users to register', argtype = bool)
fhs.option('url', 'override url for auth host (defaults to same as connect host)', default = '')
config = fhs.init(contact = 'Bas Wijnen <wijnen@debian.org>', help = 'Server for handling user data', version = '0.1')

if len(sys.argv) != 1:
	print('non-option arguments are ignored', file = sys.stderr)
# }}}

# Pending login requests (key is token, value is dict {'connection': object, 'player': player, 'user_id': user_id})
pending_player_login = {}

def make_token(container):	# {{{
	'Generate a cryptographically hard to guess token that is not present in the container dict'
	token = secrets.token_urlsafe()
	while token in container:
		token = secrets.token_urlsafe()
	return token
# }}}

class Connection: # {{{
	'''This connection is opened by the game directly (for its own data),
	or by the player through a login url. Games may request a link for
	letting managed users log in. Those will also log in through an
	instance of this class.

	Finally, when a non-managed user requests to be connected to a remote
	game, a new object of this class is created to handle that new
	connection.
	'''
	def __init__(self, remote = None): # {{{
		'Constructor. Remote is None for objects that will connect to a remote game.'
		self.remote = remote
		self.game_url = None

		# Users that are logged in on this connection.
		# Keys are user_ids given as arguments to login_*. Those are managed by the game and opaque to this program.
		# Values are dicts containing:
		#	- 'user': db username
		#	- 'token': token for logging players into this game, or None; stored in pending_player_login.
		# Example:
		# self.user = {
		#   0: {'user': 'shevek', 'token': None},		# Data management.
		#   'Player': {'user': 'shevek', 'token': {}}	# Game login, with a token for player logins.
		# }
		self.user = {}

		if remote is not None:
			# Register cleanup function.
			remote._websocket_closed = self._closed

			# Record game token if present.
			# The presence of a token means this object will attempt to log in as a managed player.
			if 'token' in remote.data['query']:
				tokens = remote.data['query']['token']
				if len(tokens) != 1:
					print('invalid tokens in query string', file = sys.stderr)
					remote._websocket_close()
					return
				self.token = tokens[0]
				if self.token not in pending_player_login:
					print('invalid token in query string', file = sys.stderr)
					remote._websocket_close()
					return
			else:
				self.token = None
		else:
			self.token = None
	# }}}

	def _closed(self):	# {{{
		'''Clean up registered tokens.'''
		for user in self.user:
			if self.user[user]['token'] is not None:
				for player in self.user[user]['token']:
					token = self.user[user]['token'][player]
					del pending_player_login[token]
				self.user[user]['token'] = {}
		# Remove this game from list of connected games.
		if self.game_url in server.games:
			del server.games[self.game_url]
	# }}}

	def get_settings(self): # {{{
		return {'allow-new-users': config['allow-new-users']}
	# }}}

# Registering new users. {{{
	def register_user(self, name, fullname, email, password):
		assert config['allow-new-users']
		return db.setup_add_user(name, fullname, email, password)
	def register_managed_player(self, name, fullname, email, password):
		if self.token not in pending_player_login:
			print('invalid game token', file = sys.stderr)
			return 'invalid game token'
		record = pending_player_login[self.token]
		connection = record['connection']
		user_id = record['user']
		game = connection.user[user_id]
		assert game['allow-new-players']
		return db.setup_add_managed_player(game['game'], name, fullname, email, password)
# }}}

# Logins. {{{
	def login_game(self, user_id, user_name, game_name, password, allow_new_players): # {{{
		'Allow connection to be used for game data access.'
		assert user_id not in self.user
		# Verify credentials
		game = db.authenticate_game(user_name, game_name, password)
		game['allow-new-players'] = allow_new_players
		if game is None:
			return False
		# Record permissions
		self.user[user_id] = {'user': game['user'], 'game': game['id'], 'player': None, 'managed': None, 'token': {}}
		return True
	# }}}

	def login_user(self, user_id, name, password): # {{{
		'Allow connection for user management access, including game login authorization.'
		assert user_id not in self.user
		# Verify credentials
		user = db.authenticate_user(name, password)
		if user is None:
			return False
		# Record permissions
		self.user[user_id] = {'user': user['id'], 'game': None, 'player': None, 'managed': None, 'token': None}
		return True
	# }}}

	def login_player(self, player_name, password): # {{{
		'''Log in player. Player data is managed by game, not by its own user.
		Game token must have been passed as part of url.
		Player token identifies player to game, it is passed unmodified.
		In response, userdata (this program) will inform game.
		No state change happens in userdata.
		'''
		if self.token not in pending_player_login:
			print('invalid game token', file = sys.stderr)
			return False
		record = pending_player_login[self.token]
		connection = record['connection']
		user_id = record['user']
		player_id = record['player']
		game = connection.user[user_id]
		player = db.authenticate_player(game['game'], player_name, password)
		if player is None:
			print('invalid player credentials', file = sys.stderr)
			return False
		self.drop_token(user_id, self.token)
		connection.remote.setup_connect_player.event(user_id, player_id, player['name'], player['fullname'])
		return True
	# }}}

	def create_token(self, user_id, player_id): # {{{
		'''Allow a player to log in on this game.
		The returned token must be passed by the user in the query string of the request.
		This allows the browser to send it for its connection that calls login_player().
		'''
		assert self.user[user_id]['token'] is not None
		if player_id in self.user[user_id]['token']:
			return self.user[user_id]['token'][player_id]
		token = make_token(pending_player_login)
		self.user[user_id]['token'][player_id] = token
		pending_player_login[token] = {'connection': self, 'user': user_id, 'player': player_id}
		return token
	# }}}

	def drop_token(self, user_id, token): # {{{
		'''Revoke a previously generated token.
		After this, players using the token will no longer be able to log in.
		'''
		assert token in pending_player_login
		record = pending_player_login[token]
		assert record['connection'].user[record['user']]['token'][record['player']] == token
		pending_player_login.pop(token)
		del record['connection'].user[record['user']]['token'][record['player']]
	# }}}

	def connect(self, user_id, game_url, attrs, player): # {{{
		'''Connect to game server.
		This is called when a remote (to the game) player has logged in to this userdata.
		This function can only be called by a logged in user.'''
		wake = (yield)
		assert self.is_user(user_id)
		storage = db.setup_get_player(self.user[user_id]['user'], game_url, player)
		assert storage is not None
		if game_url in server.games:
			# Game is already connected, use existing connection.
			game = server.games[game_url]['game']
			connection = server.games[game_url]['connection']
			uid = server.games[game_url]['uid'] + 1
			server.games[game_url]['uid'] = uid
			connection.user[uid] = {'user': self.user[user_id]['user'], 'game': None, 'player': storage['id'], 'managed': None, 'token': None}
			game.setup_connect.bg(wake, uid, storage['fullname'], **attrs)
			return (yield)
		else:
			# Game is not connected, create new connection.
			connection = Connection()	# Create new object for this connection.
			connection.game_url = game_url
			uid = 0
			connection.user[uid] = {'user': self.user[user_id]['user'], 'game': None, 'player': storage['id'], 'managed': None, 'token': None}
			def accept(remote):
				assert connection.remote is None
				connection.remote = remote
				return connection
			attrs['uid'] = uid
			attrs['name'] = storage['fullname']
			game = websocketd.RPC(game_url + '?' + '&'.join('%s=%s' % (key, urllib.parse.quote_plus(str(value))) for key, value in attrs.items()), accept)	# XXX This will block and allows a denial of service attack.
			game._websocket_closed = connection._closed
			server.games[game_url] = {'game': game, 'uid': uid, 'connection': connection}
	# }}}

	def access_game(self, user_id, new_user_id, user_name, game_name): # {{{
		pass # TODO
	# }}}

	def access_player(self, user_id, new_user_id, url, player_name): # {{{
		pass # TODO
	# }}}

	def access_managed_player(self, user_id, new_user_id, player_name): # {{{
		assert new_user_id not in self.user
		player_id = db.find_managed(self.user[user_id]['game'], player_name)
		assert player_id is not None
		self.user[new_user_id] = {'user': self.user[user_id]['user'], 'game': None, 'player': None, 'managed': player_id, 'token': None}
	# }}}
# }}}

# Database management. {{{
# Games (for use with login_game()). {{{
	def list_games(self, user_id): # {{{
		'Can only be called for logged in users. Lists all games (for use by login_game()) for that user.'
		assert self.is_user(user_id)
		return db.setup_list_games(self.user[user_id]['user'])
	# }}}

	def add_game(self, user_id, game_name, game_fullname, password): # {{{
		'Can only be called for logged in users. Creates a new game in the database.'
		assert self.is_user(user_id)
		return db.setup_add_game(self.user[user_id]['user'], game_name, game_fullname, password)
	# }}}

	def update_game(self, user_id, old_game_name, game_name, game_fullname, password): # {{{
		'Can only be called for logged in users. Updates settings for an existing game in the database.'
		assert self.is_user(user_id)
		game_id = db.find_game(self.user[user_id]['user'], old_game_name)
		assert game_id is not None
		return db.setup_update_game(game_id, self.user[user_id]['user'], game_name, game_fullname, password)
	# }}}

	def remove_game(self, user_id, game_name): # {{{
		'Can only be called for logged in users. Removes a game from the database.'
		assert self.is_user(user_id)
		game_id = db.find_game(self.user[user_id]['user'], game_name)
		assert game_id is not None
		return db.setup_remove_game(game_id)
	# }}}
# }}}

# Remote players. {{{
	def list_players(self, user_id, url = None): # {{{
		'Can only be called for logged in users. Lists all remote players (for use with connect()) of that user.'
		assert self.is_user(user_id)
		return db.setup_list_players(self.user[user_id]['user'], url)
	# }}}

	def add_player(self, user_id, url, player_name, player_fullname, is_default): # {{{
		'Can only be called for logged in users. Adds a player for a game to the database.'
		assert self.is_user(user_id)
		return db.setup_add_player(self.user[user_id]['user'], url, player_name, player_fullname, is_default)
	# }}}

	def update_player(self, old_player_name, user_id, url, player_name, player_fullname, is_default): # {{{
		'Can only be called for logged in users. Updates settings of an existing player in the database.'
		assert self.is_user(user_id)
		playerid = db.find_player(self.user[user_id]['user'], url, old_player_name)
		assert playerid is not None
		return db.setup_update_player(playerid, self.user[user_id]['user'], url, player_name, player_fullname, is_default)
	# }}}

	def remove_player(self, user_id, url, player_name): # {{{
		'Can only be called for logged in users. Removes a player from the database.'
		assert self.is_user(user_id)
		playerid = db.find_player(self.user[user_id]['user'], url, player_name)
		assert playerid is not None
		return db.setup_remove_player(playerid)
	# }}}
# }}}

# Local (managed) players. {{{
	def list_managed_players(self, user_id, game_name = None): # {{{
		'''Can only be called for logged in users and logged in games. Lists all managed players (for login_player()) for given game of that user.
		For logged in games, game_name must be set to its own game (or None)
		'''
		assert self.is_user(user_id) or self.is_game(user_id)
		if game_name is None:
			assert self.is_game(user_id)
			game_id = self.user[user_id]['game']
		else:
			game_id = db.find_game(self.user[user_id]['user'], game_name)
			if self.is_game(user_id):
				assert self.user[user_id]['game'] == game_id
		return [{key: value for key, value in x.items() if key in ('name', 'fullname', 'email')} for x in db.setup_list_managed_players(game_id)]
	# }}}

	def add_managed_player(self, user_id, game_name, name, fullname, email, password): # {{{
		'Can only be called for logged in users. Adds a managed player (for login_player()) for a game to the database.'
		assert self.is_user(user_id) or self.is_game(user_id)
		game_id = find_game(self.user[user_id]['user'], game_name)
		assert game_id is not None
		if self.is_game(user_id):
			assert self.user[user_id]['game'] == game_id
		return db.setup_add_managed_player(game_id, name, fullname, email, password)
	# }}}

	def update_managed_player(self, user_id, old_player_name, game_name, name, fullname, email, password): # {{{
		'Can only be called for logged in users. Updates settings of an existing player in the database.'
		assert self.is_user(user_id) or self.is_game(user_id)
		game_id = db.find_game(self.user[user_id]['user'], game_name)
		assert game_id is not None
		if self.is_game(user_id):
			assert self.user[user_id]['game'] == game_id
		managedid = db.find_managed(game_id, old_player_name)
		assert managedid is not None
		return db.setup_update_managed_player(managedid, game_id, name, fullname, email, password)
	# }}}

	def remove_managed_player(self, user_id, game_name, name): # {{{
		'Can only be called for logged in users. Removes a player from the database.'
		assert self.is_user(user_id) or self.is_game(user_id)
		game_id = find_game(self.user[user_id]['user'], game_name)
		assert game_id is not None
		if self.is_game(user_id):
			assert self.user[user_id]['game'] == game_id
		playerid = find_managed(game_id, name)
		return db.setup_remove_managed_player(playerid)
	# }}}
# }}}
# }}}

	def disconnected(self, user_id): # {{{
		'User disconnected from game; drop userdata connection, optionally close connection to game'
		if self.user[user_id]['token'] is not None:
			del pending_player_login[self.user[user_id]['token']]
			self.user[user_id]['token'] = None
		del self.user[user_id]
		if len(self.user) == 0:
			self.remote._websocket_close()
			del server.games[self.game_url]
	# }}}

	def is_user(self, user_id):
		assert user_id in self.user
		user = self.user[user_id]
		return user['game'] is None and user['player'] is None and user['managed'] is None

	def is_game(self, user_id):
		assert user_id in self.user
		return self.user[user_id]['game'] is not None

	def is_player(self, user_id):
		assert user_id in self.user
		return self.user[user_id]['player'] is not None

	def is_managed(self, user_id):
		assert user_id in self.user
		return self.user[user_id]['managed'] is not None

	# Database access. {{{
	def _mktable(self, user_id, table): # {{{
		if self.is_game(user_id):
			# This is a game connection.
			return db.global_prefix + 'g%x_' % self.user[user_id]['game'] + table
		if self.is_player(user_id):
			# This is a (remote) player connection.
			return db.global_prefix + 'p%x_' % self.user[user_id]['player'] + table
		if self.is_managed(user_id):
			# This is a managed player connection.
			return db.global_prefix + 'm%x_' % self.user[user_id]['managed'] + table
		raise PermissionError('this connection has no database access.')
	# }}}
	def show_tables(self, user_id): # {{{
		'Return all tables for given game, accessible to logged in user.'
		assert user_id in self.user
		prefix = self._mktable(user_id, '')
		return [x[len(prefix):] for x in db.read1('SHOW TABLES') if x.startswith(prefix)]
	# }}}

	def describe(self, user_id, table): # {{{
		'give table description in mysql format; interface may not be stable. Use show_columns instead if you can.'
		# This returns the output from mysql, which may or may not be a stable interface.
		assert user_id in self.user
		return db.read('DESCRIBE %s' % self._mktable(user_id, table))
	# }}}

	def show_columns(self, user_id, table): # {{{
		'return column names of given table'
		assert user_id in self.user
		# Use read1 to only get the first column, which is the column names of the table.
		return db.read1('DESCRIBE %s' % self._mktable(user_id, table))
	# }}}

	def create_table(self, user_id, table, columns): # {{{
		'Create new table for this player.'
		assert user_id in self.user
		if isinstance(columns, dict):
			columns = [(k, v) for k, v in columns.items()]
		for c in columns:
			db.assert_is_id(c[0])
		db.write('CREATE TABLE %s (%s)' % (self._mktable(user_id, table), ', '.join('%s %s' % tuple(c) for c in columns)))
	# }}}

	def drop_table(self, user_id, table): # {{{
		'Drop a table for this player.'
		assert user_id in self.user
		db.write('DROP TABLE %s' % (self._mktable(user_id, table)))
	# }}}

	def insert(self, user_id, table, data): # {{{
		'''Insert a new record in the given table.
		Return last_insert_id().'''
		assert user_id in self.user
		if isinstance(data, dict):
			data = [(k, v) for k, v in data.items()]
		for d in data:
			db.assert_is_id(d[0])
		db.write('INSERT INTO %s (%s) VALUES (%s)' % (self._mktable(user_id, table), ', '.join(d[0] for d in data), ', '.join('%s' for d in data)), *tuple(d[1] for d in data))
		return db.read1('SELECT LAST_INSERT_ID()')[0]
	# }}}

	def delete(self, user_id, table, condition): # {{{
		'Delete zero or more records from the given table.'
		assert user_id in self.user
		c = self._parse_condition(condition)
		db.write('DELETE FROM %s%s' % (self._mktable(user_id, table), c[0]), *c[1])
	# }}}

	def update(self, user_id, table, data, condition): # {{{
		'Update records in given table.'
		assert user_id in self.user
		c = self._parse_condition(condition)
		if isinstance(data, dict):
			data = [(k, v) for k, v in data.items()]
		columns = tuple(d[0] for d in data)
		values = tuple(d[1] for d in data)
		for col in columns:
			db.assert_is_id(col)
		db.write('UPDATE %s SET %s%s' % (self._mktable(user_id, table), ', '.join('%s = %%s' % col for col in columns), c[0]), *(values + c[1]))
	# }}}

	def select(self, user_id, table, columns, condition = ()): # {{{
		'Retrieve data from given table.'
		assert user_id in self.user
		if isinstance(columns, str):
			columns = (columns,)
		for c in columns:
			db.assert_is_id(c)
		c = self._parse_condition(condition)
		return db.read('SELECT %s FROM %s%s' % (', '.join(columns), self._mktable(user_id, table), c[0]), *c[1])
	# }}}

	def managed_select(self, user_id, player, table, columns, condition = ()): # {{{
		'''Retrieve data from given table of managed player.
		This function must only be called from a game connection.
		It selects data from the managed player for the connection's game.
		'''
		assert self.is_game(user_id)
		game_id = self.user[user_id]['game']
		assert game_id is not None

		if isinstance(columns, str):
			columns = (columns,)
		for c in columns:
			db.assert_is_id(c)
		c = self._parse_condition(condition)
		mid = db.find_managed(game_id, player)
		t = db.global_prefix + 'm%x_' % mid + table
		return db.read('SELECT %s FROM %s%s' % (', '.join(columns), t, c[0]), *c[1])
	# }}}

	def _parse_condition(self, condition, simple = False): # {{{
		'''Parse a condition argument.
		Argument is an RPN expression tree.
		Nodes are ('and' | 'or' | 'not', branch1, branch2) (branch2 is omitted for not)
		Leaves are ('=' | '>' | '<' | '>=' | '<=' | '<>' | 'like', column, value)
		Return a 2-tuple, with the string in the query as the first item and the arguments as the second.
		'''
		# XXX: support more complex conditions.
		if len(condition) == 0:
			return ('', ())
		if condition[0].upper() in ('AND', 'OR'):
			c1 = self._parse_condition(condition[1], True)
			c2 = self._parse_condition(condition[2], True)
			return ' WHERE ' + c1[0] + ' ' + condition[0].upper() + ' ' + c2[0], c1[1] + c2[1]
		if condition[0].upper() not in ('=', '<', '>', '<=', '>=', '<>', 'LIKE'):
			raise NotImplementedError('Only simple conditions are supported at the moment')
		db.assert_is_id(condition[1])
		if condition[0] in ('=', '<>') and condition[2] is None:
			neg = '' if condition[0] == '=' else ' NOT'
			if simple:
				return (condition[1] + ' IS' + neg + ' NULL', ())
			else:
				return (' WHERE ' + condition[1] + ' IS' + neg + ' NULL', ())
		if simple:
			return (condition[1] + ' ' + condition[0].upper() + ' %s', (condition[2],))
		else:
			return (' WHERE ' + condition[1] + ' ' + condition[0].upper() + ' %s', (condition[2],))
	# }}}
	# }}}

	def _show_columns(self, user_id, t): # {{{
		cmd = db.read('SHOW CREATE TABLE {}'.format(self._mktable(user_id, t)))[0][1]
		p = re.match('CREATE TABLE `.*?` \((.*)\) ENGINE=.*$', cmd, re.S)
		assert p is not None
		columns = [x.strip() for x in p.group(1).split(',')]
		ret = {}
		unique = set()
		pkey = None
		for c in columns:
			pk = re.match('^PRIMARY KEY \(`(.*)`\)$', c)
			if pk is not None:
				pkey = pk.group(1)
				continue
			u = re.match('^UNIQUE KEY `(.*)` \(`(.*)`\)$', c)
			if u is not None:
				assert u.group(1) == u.group(2)
				unique.add(u.group(1))
				continue
		for c in columns:
			if not c.startswith('`'):
				continue
			col = re.match('^`(.*?)` (.*)$', c)
			ret[col.group(1)] = col.group(2)
			if col.group(1) in unique:
				ret[col.group(1)] += ' UNIQUE'
			if col.group(1) == pkey:
				ret[col.group(1)] += ' PRIMARY KEY'
		return ret
	# }}}
	def setup_db(self, user_id, data, remove = True, add = True, replace = False): # {{{
		'Create tables of columns'
		assert user_id in self.user
		tables = self.show_tables(user_id)
		if remove or replace:
			for t in tables:
				if replace or (remove and t not in data):
					self.drop_table(user_id, t)
		if add or replace:
			for t in data:
				datacolumns = {x[0]: x[1] for x in data[t]}
				if replace or (add and t not in tables):
					self.create_table(user_id, t, data[t])
				elif t not in tables:
					continue
				# The target table exists. Check the columns.
				columns = self.show_columns(user_id, t)
				for column in columns:
					if column not in datacolumns:
						if remove:
							db.write('ALTER TABLE {} DROP COLUMN {}'.format(self._mktable(user_id, t), column))
						else:
							print('obsolete column %s in table %s for user %s' % (column, t, user_id), file = sys.stderr)
				desc = self._show_columns(user_id, t)	# Get column descriptions to know if a primary key is defined.
				for column in datacolumns:
					if column not in columns:
						if add:
							coldesc = datacolumns[column]
							if (' PRIMARY KEY' in coldesc and	# The new column is the primary key.
									(column not in desc or ' PRIMARY KEY' not in desc[column]) and	# The column does not exist yet, or is not the primary key yet.
									any(' PRIMARY KEY' in desc[x] for x in desc)):	# There is a primary key in the current table.
								db.write('ALTER TABLE {} DROP PRIMARY KEY'.format(self._mktable(user_id, t)))
							elif ' PRIMARY KEY' in datacolumns[column] and column in desc and ' PRIMARY KEY' in desc[column]:
								coldesc = coldesc.replace(' PRIMARY KEY', '')
							db.write('ALTER TABLE {} ADD {} {}'.format(self._mktable(user_id, t), column, coldesc))
						else:
							print('extra column %s defined in table %s for user %s' % (column, t, user_id), file = sys.stderr)
							continue
				desc = self._show_columns(user_id, t)	# Get column descriptions including newly created columns.
				for column in desc:
					if column not in datacolumns:
						continue
					if desc[column] != datacolumns[column]:
						if add:
							coldesc = datacolumns[column]
							if ' PRIMARY KEY' in datacolumns[column] and (column not in desc or ' PRIMARY KEY' not in desc[column]) and any(' PRIMARY KEY' in x for x in desc):
								db.write('ALTER TABLE {} DROP PRIMARY KEY'.format(self._mktable(user_id, t)))
							elif ' PRIMARY KEY' in datacolumns[column] and column in desc and ' PRIMARY KEY' in desc[column]:
								coldesc = coldesc.replace(' PRIMARY KEY', '')
							db.write('ALTER TABLE {} MODIFY COLUMN {} {}'.format(self._mktable(user_id, t), column, coldesc))
				desc = self._show_columns(user_id, t)	# Get column descriptions including newly modified columns.
				for column in desc:
					if column not in datacolumns:
						continue
					if desc[column] != datacolumns[column]:
						print('db column description "%s" does not match definition "%s" for table %s of user %s.' % (desc[column], datacolumns[column], t, user_id), file = sys.stderr)
	# }}}
# }}}

server = websocketd.RPChttpd(config['port'], Connection, httpdirs = ('html',))
server.games = {}
server.player = {}
print('server is running on port %s' % config['port'])

while True:
	try:
		websocketd.fgloop()
	except ValueError:
		print('ignoring exception: %s' % str(sys.exc_info()[1]))

# vim: set foldmethod=marker :
