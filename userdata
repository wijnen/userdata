#!/usr/bin/python3
# userdata: system for user authentication and data storage.
# This is the server program, which manages the data.

'''
Use cases:
A. (usually web-based) game needs to store data. Connects to userdata, sends user to userdata through direct channel; user authenticates and grants permissions; game can access data.
	Summary: player is owner of user data.
	game is only trusted by userdata to access parts that it was permitted to access by the data's owner
	login screen allows the user to set up storage
	Because login is through browser, passwords need to be used. (possibly use keys as an option.)

B. game needs to store data. Connects to userdata, logs in and uses data.
	Summary: game is the owner of user data.
	if there are multiple players, the game handles this.
	the user who runs the game needs to set up credentials to userdata
	the player never sees any interface elements from userdata.
	Login is through websocket, so public key encryption is used for maximum security.

Interface:

A.
	Game accepts connection from player
	Game has built-in userdata server address, or gets it from player
	Game connects userdata and calls request_login_url(game_info) -> login_url
	Game sends player to login_url
	Game calls wait_for_login(), which blocks (game usually calls it in the background.)
	Player connects to userdata through login_url (which includes a token)
	Player logs in (TODO: and grants permissions)
	Userdata informs game by returning the wait_for_login() call.
	Game can now use data through the interface.

B.
	Game connects to userdata
	Game request login token using request_login_token(game)
	Userdata returns a token
	Game signs the token with its private key and calls finish_login(signature)
	Game can now use data through the interface.

Alternative B (usually disabled by userdata):
	Game connects to userdata
	Game calls login(name, password)
	Game can now use data through the interface.

Database format:

All tables have a prefix if set on the commandline using --prefix.
User tables have an additional (after the global prefix) prefix of 'username-gamename-'.
Userdata never changes user tables except as asked by authorized users.
Internal data is (all tables have the global prefix):
	user: name, key, game1, game2, password, email	(if game1 is NULL, this is the master key for the user.)


'''

import sys
import secrets
import websocketd
import db
import re
import fhs
fhs.option('port', 'Port to listen on for game server requests', default = '8879')
fhs.option('authport', 'Port to listen on for authentication requests; leave empty for same as game server requests', default = '')
fhs.option('prefix', 'Prefix to use for all database tables', default = '')
fhs.option('allow-new-users', 'Allow new users to register', argtype = bool)
fhs.option('url', 'override url for auth host (defaults to same as connect host)', default = '')
config = fhs.init(contact = 'Bas Wijnen <wijnen@debian.org>', help = 'Server for handling user data', version = '0.1')
prefix = config['prefix']

if len(sys.argv) != 1:
	print('non-option arguments are ignored', file = sys.stderr)

pending = {}

def _assert_is_id(name):
	'Check that a name is a valid id (mostly to protect against injections)'
	assert isinstance(name, str)
	assert re.match('^[a-zA-Z_][a-zA-Z_0-9]*$', name)

def _mangle_name(self, name):
	# TODO: actually mangle instead of refusing.
	_assert_is_id(name)
	return name

class Auth:
	'''User connection.

	This connection is opened directly by the user's browser after being
	sent there by the game with a token.

	Through this connection, private parts of userdata may be modified
	(with sufficient credentials).
	'''

	def __init__(self, remote):
		self.remote = remote
		try:
			self.token = remote.data['query']['token'][0]
			self.game = pending.pop(self.token)
		except:
			print('not a valid token; refusing connection', file = sys.stderr)
			self.remote.close()

	def get_info(self):
		return self.game.game['name']

	def register(self, name, password):
		# TODO: Put flexible limits on this? Require e-mail confirmation?
		if not config['allow-new-users']:
			return 'Registration failed: New users are not allowed by this userdata instance.'
		return db.setup_add_user(_mangle_name(name), password, prefix + 'user')

	def login(self, name, password):
		name = _mangle_name(name)
		if not db.authenticate(name, password, prefix + 'user'):
			return 'Authentication failed.'
		self.game.user = name
		self.game.userprefix = self.game.user + '-'
		self.game.logged_in()
		return None

	# TODO: manage permissions.

class Game:
	'''Game connection.

	This connection is opened by the game. It may be used to authenticate
	directly, if the game is trusted by the owner of the userdata account
	(and therefore can present the credentials), or it can request a link
	for letting the user log in.

	If the user needs to log in, this happens through an Auth connection.
	'''
	def __init__(self, remote):
		self.remote = remote
		self.logged_in = lambda: None
		self.remote.closed = lambda: self.logged_in()
		self.user = None
		assert remote.data['query'] == {}

	def _mktable(self, table):
		'Create SQL table name'
		return prefix + self.userprefix + self.gameprefix + table

	def request_login_token(self, game):
		'Game wants to log in without user interaction.'
		# TODO: Check that game is known (so public key is available).
		self.login_token = secrets.token_urlsafe()
		return self.login_token

	def finish_login(self, signature):
		'Game login without user interaction. Message is token signature.'
		# TODO
		return 'This has not yet been implemented'

	def login(self, user, password):
		'Game logs in without user interaction. This should normally be disabled.'
		# TODO: use public key authentication instead of password.
		name = _mangle_name(name)
		if not db.authenticate(name, password, prefix + 'user'):
			return 'Authentication failed.'
		self.user = name
		self.userprefix = self.user + '-'
		return None

	def request_login_url(self, game):
		'Present game info; retrieve auth token'
		self.game = game
		_assert_is_id(game['prefix'])
		self.gameprefix = game['prefix'] + '-'
		self.auth_token = None
		while self.auth_token is None or self.auth_token in pending:
			self.auth_token = secrets.token_urlsafe()
		pending[self.auth_token] = self
		self.logged_in = lambda: None
		return (config['url'] or self.remote.data['url']) + '?token=' + self.auth_token

	def wait_for_login(self):
		'Wait for login to complete. If already logged in, return immediately.'
		wake = (yield)
		if self.user is not None:
			return None
		self.logged_in = wake
		yield
		self.logged_in = lambda: None
		if self.auth_token in pending:
			pending.pop(self.auth_token)
		if self.user is not None:
			return None
		return 'Login failed: Connection lost'

	def create_table(self, table, columns):
		assert self.user is not None
		for c in columns:
			_assert_is_id(c)
		db.write('CREATE TABLE %s (%s)' % (self._mktable(table), ', '.join('%s %s' % c for c in columns)))

	def drop_table(self, table):
		assert self.user is not None
		db.write('DROP TABLE %s' % (self._mktable(table)))

	def insert(self, table, data):
		assert self.user is not None
		if isinstance(data, dict):
			data = [(k, v) for k, v in data.items()]
		for d in data:
			_assert_is_id(d[0])
		db.write('INSERT INTO %s (%s) VALUES (%s)' % (self._mktable(table), ', '.join(d[0] for d in data), ', '.join('%s' for d in data)), *tuple(d[1] for d in data))

	def delete(self, table, condition):
		assert self.user is not None
		c = self._parse_condition(condition)
		db.write('DELETE FROM %s%s' % (self._mktable(table), c[0]), *c[1])

	def update(self, table, data, condition):
		assert self.user is not None
		c = self._parse_condition(condition)
		if isinstance(data, dict):
			data = [(k, v) for k, v in data.items()]
		columns = tuple(d[0] for d in data)
		values = tuple(d[1] for d in data)
		for c in columns:
			_assert_is_id(c)
		db.write('UPDATE %s SET %s%s' % (self._mktable(table), ', '.join('%s = %%s' % columns), c[0]), values + c[1])

	def select(self, columns, table, condition):
		assert self.user is not None
		for c in columns:
			_assert_is_id(c)
		c = self._parse_condition(condition)
		return db.read('SELECT %s FROM %s%s' % (', '.join(columns), self._mktable(table), c[0]), *c[1])

	def _parse_condition(self, condition):
		'''Parse a condition argument.
		Argument is an RPN expression tree.
		Nodes are ('and' | 'or' | 'not', branch1, branch2) (branch2 is omitted for not)
		Leaves are ('=' | '>' | '<' | '>=' | '<=' | '<>' | 'like', column, value)
		Return a 2-tuple, with the string in the query as the first item and the arguments as the second.
		'''
		# TODO: support more complex conditions.
		if len(condition) == 0:
			return ('', ())
		if condition[0] not in ('=', '<', '>', '<=', '>=', '<>', 'like'):
			raise NotImplementedError('Only simple conditions are supported at the moment')
		_assert_is_id(condition[1])
		return (' WHERE ' + condition[1] + ' ' + condition[0].upper() + ' %s', (condition[2],))

def Connection(remote):
	'Return appropriate object for new connection.'
	if len(remote.data['query']) == 0:
		return Game(remote)
	else:
		return Auth(remote)

server = websocketd.RPChttpd(config['port'], Connection if config['authport'] == '' else Game, httpdirs = ('html',))
if config['authport'] != '':
	authserver = websocketd.RPChttpd(config['authport'], Auth)

print('server is running')
websocketd.fgloop()
