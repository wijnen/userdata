#!/usr/bin/python3
# userdata: system for user authentication and data storage.
# This is the server program, which manages the data.

'''
Interface: {{{
- Game connects to userdata for full access, to store game data and (optionally) local users. Credentials are passed by the game (which gets them from the command line or a configuration file): login_game()
- When a player connects to the game, a userdata server is selected based on the game settings (with/without default; allow-local, allow-external)
- Player connects to userdata and logs in. A token is returned.
- Game connects to userdata (or uses existing connection) and provides the token.
- Game uses the connection to handle player data.

Possible connections:

From game:
	- login_game(name, password, game_id): use game data; limited access. Set self.game = game_id
	- login_token(token, player_id): return player name; use data for player that provided the token. Set self.player[id] = (username, None) or (username, playername)

From user:
	- login_user(name, password): manage user data; full access. Set self.user = name.

From player:
	- login_user(name, password, game_id): return token; allow using data in game; only allow access based on the game. Connection is closed when game provides token. Set server.player[token] = self.
	- login_player(username, playername, password, game_id): return token; same as above, use player account inside user's data. Set server.player[token] = self.

Database format:

All tables have a prefix if set on the commandline using --prefix.
User tables have an additional (after the global prefix) prefix of 'username-gamename-playername-'.
For game data, playername is "". In other words, the prefix is 'username-gamename--'.
Userdata never changes user tables except as asked by authorized users.
Internal data is (all tables have the global prefix):
	user: name, key, game1, game2, password, email	(if game1 is NULL, this is the master key for the user.)

}}}
'''

# Imports and config. {{{
import sys
import secrets
import websocketd
import db
import re
import fhs
fhs.option('port', 'Port to listen on for game server requests', default = '8879')
fhs.option('authport', 'Port to listen on for authentication requests; leave empty for same as game server requests', default = '')
fhs.option('prefix', 'Prefix to use for all database tables', default = '')
fhs.option('allow-new-users', 'Allow new users to register', argtype = bool)
fhs.option('url', 'override url for auth host (defaults to same as connect host)', default = '')
config = fhs.init(contact = 'Bas Wijnen <wijnen@debian.org>', help = 'Server for handling user data', version = '0.1')
prefix = config['prefix']

if len(sys.argv) != 1:
	print('non-option arguments are ignored', file = sys.stderr)
# }}}

# Pending login requests (key is token, value is requesting server Game object)
pending = {}

def _assert_is_id(name): # {{{
	'Check that a name is a valid id (mostly to protect against injections)'
	assert isinstance(name, str)
	assert re.match('^[a-zA-Z_][a-zA-Z_0-9]*$', name)
# }}}

def _mangle_name(self, name): {{{
	# TODO: actually mangle instead of refusing.
	_assert_is_id(name)
	return name
# }}}

class Connection: # {{{
	'''This connection is opened by the game directly, or by the player
	through a login url. It may be used to authenticate directly, if the
	game is trusted by the owner of the userdata account (and therefore can
	present the credentials), or it can request a link for letting the user
	log in.
	'''
	def __init__(self, remote): # {{{
		self.remote = remote
		self.game = None	# game id for connection from game.
		self.user = None	# user name for data management connection from user (there is no game).
		self.player = {}	# user name and/or player name for connection from game. Key is game-provided id; value is (username, playername or None).
	# }}}

	def _mktable(self, player, table, game): # {{{
		'Create SQL table name'
		return prefix + self.userprefix + self.gameprefix[game] + self.playerprefix + table
	# }}}

	def login_game(self, user, password, game): # {{{
		'Game logs in without player interaction.'
		# XXX: use public key authentication instead of password.
		try:
			assert isinstance(game, dict) and 'id' in game and isinstance(game['id'], str)
			assert isinstance(user, str) and isinstance(password, str)
		except AssertionError:
			return 'Invalid parameters passed to login_game.'
		name = _mangle_name(user)
		# FIXME: everything below needs to be updated.
		prefix = db.authenticate(name, password, game['id'], prefix + 'user')
		if prefix is None:
			return 'Authentication failed.'
		_assert_is_id(game['prefix'])
		self.user = name
		self.userprefix = self.user + '-'
		self.game = game
		self.gameprefix = prefix
		return None
	# }}}

	def login_player(self, player, password, game_id = None): # {{{
		'Player logs in.'
		if self.user is None:
			# External userdata.
			del self.remote.closed
			assert isinstance(game_id, str)
			prefix = db.authenticate(name, password, game_id, prefix + 'user')
			if prefix is None:
				return 'Authentication failed.'
			self.userprefix = _mangle_name(name) + '-'
			self.gameprefix = prefix
			self.playerprefix = ''
		else:
			# Local userdata.
			assert game_id is None
			if not db.authenticate(name, password, None, prefix + self.userprefix + self.gameprefix + 'user'):
				return 'Authentication failed.'
			self.playerprefix = _mangle_name(name) + '-'
		assert self.token in pending
		game, player_id = pending.pop(self.token)
		if player_id in game._logged_in:
			game._logged_in.pop(player_id)()
	# }}}

	def request_login_url(self, player_id): # {{{
		'Present game info; retrieve auth url'
		assert player_id not in self.auth_token
		self.auth_token[player_id] = None
		while self.auth_token[player_id] is None or self.auth_token[player_id] in pending:
			self.auth_token[player_id] = secrets.token_urlsafe()
		pending[self.auth_token[player_id]] = (self, player_id)
		return (config['url'] or self.remote.data['url']) + '?token=' + self.auth_token[player_id]
	# }}}

	def wait_for_login(self, player_id): # {{{
		'Wait for login to complete. If already logged in, return immediately.'
		wake = (yield)
		if self.user is not None:
			return None
		self._logged_in[player_id] = wake
		yield
		if self.user is not None:
			return None
		return 'Login failed: Connection lost'
	# }}}

	# Database access. {{{
	def create_table(self, player, table, columns): # {{{
		assert self.user is not None
		for c in columns:
			_assert_is_id(c)
		db.write('CREATE TABLE %s (%s)' % (self._mktable(player, table), ', '.join('%s %s' % c for c in columns)))
	# }}}

	def drop_table(self, player, table): # {{{
		assert self.user is not None
		db.write('DROP TABLE %s' % (self._mktable(player, table)))
	# }}}

	def insert(self, player, table, data): # {{{
		assert self.user is not None
		if isinstance(data, dict):
			data = [(k, v) for k, v in data.items()]
		for d in data:
			_assert_is_id(d[0])
		db.write('INSERT INTO %s (%s) VALUES (%s)' % (self._mktable(player, table), ', '.join(d[0] for d in data), ', '.join('%s' for d in data)), *tuple(d[1] for d in data))
	# }}}

	def delete(self, player, table, condition): # {{{
		assert self.user is not None
		c = self._parse_condition(condition)
		db.write('DELETE FROM %s%s' % (self._mktable(player, table), c[0]), *c[1])
	# }}}

	def update(self, player, table, data, condition): # {{{
		assert self.user is not None
		c = self._parse_condition(condition)
		if isinstance(data, dict):
			data = [(k, v) for k, v in data.items()]
		columns = tuple(d[0] for d in data)
		values = tuple(d[1] for d in data)
		for c in columns:
			_assert_is_id(c)
		db.write('UPDATE %s SET %s%s' % (self._mktable(player, table), ', '.join('%s = %%s' % columns), c[0]), values + c[1])
	# }}}

	def select(self, player, columns, table, condition): # {{{
		assert self.user is not None
		for c in columns:
			_assert_is_id(c)
		c = self._parse_condition(condition)
		return db.read('SELECT %s FROM %s%s' % (', '.join(columns), self._mktable(player, table), c[0]), *c[1])
	# }}}

	def _parse_condition(self, condition): # {{{
		'''Parse a condition argument.
		Argument is an RPN expression tree.
		Nodes are ('and' | 'or' | 'not', branch1, branch2) (branch2 is omitted for not)
		Leaves are ('=' | '>' | '<' | '>=' | '<=' | '<>' | 'like', column, value)
		Return a 2-tuple, with the string in the query as the first item and the arguments as the second.
		'''
		# XXX: support more complex conditions.
		if len(condition) == 0:
			return ('', ())
		if condition[0] not in ('=', '<', '>', '<=', '>=', '<>', 'like'):
			raise NotImplementedError('Only simple conditions are supported at the moment')
		_assert_is_id(condition[1])
		return (' WHERE ' + condition[1] + ' ' + condition[0].upper() + ' %s', (condition[2],))
	# }}}
	# }}}
# }}}

server = websocketd.RPChttpd(config['port'], Connection, httpdirs = ('html',))
server.player = {}
print('server is running')

websocketd.fgloop()

# vim: set foldmethod=marker :
